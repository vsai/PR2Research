%This work is licensed under the
%Creative Commons Attribution-Share Alike 3.0 United States License.
%To view a copy of this license, visit
%http://creativecommons.org/licenses/by-sa/3.0/us/ or send a letter to
%Creative Commons,
%171 Second Street, Suite 300,
%San Francisco, California, 94105, USA.

\section{FLAC Decoding}

The basic process for decoding a FLAC file is as follows:
\par
\noindent
\ALGORITHM{a FLAC encoded file}{PCM samples}
\SetKwData{HEADER}{file header}
\SetKwData{PCMCOUNT}{PCM frame count}
\SetKwData{MDSUM}{MD5 sum}
$\HEADER \leftarrow$ \READ 4 bytes\;
\ASSERT $\text{\HEADER} = \texttt{"fLaC"}$\;
\hyperref[flac:read_metadata]{get \PCMCOUNT and \MDSUM from STREAMINFO metadata block}\;
skip remaining metadata blocks\;
initialize stream MD5\;
\While{$\PCMCOUNT > 0$}{
  \hyperref[flac:decode_frame]{decode FLAC frame to 1 or more PCM frames}\;
  deduct FLAC frame's block size from $\PCMCOUNT$\;
  \hyperref[flac:update_md5]{update stream MD5 sum with decoded PCM frame data}\;
  \Return decoded PCM frames\;
}
\ASSERT STREAMINFO \MDSUM = stream MD5 sum
\EALGORITHM
\begin{figure}[h]
\includegraphics{flac/figures/stream3.pdf}
\end{figure}
\par
All of the fields in the FLAC stream are big-endian.\footnote{Except
for the length fields in the VORBIS\_COMMENT metadata block.
However, this block is not needed for decoding.
}

\clearpage

\subsection{Reading Metadata Blocks}
\label{flac:read_metadata}
{\relsize{-1}
\ALGORITHM{the FLAC file stream}{STREAMINFO values used for decoding}
\SetKwData{LAST}{last}
\SetKwData{TYPE}{type}
\SetKwData{SIZE}{size}
\SetKwData{MINBLOCKSIZE}{minimum block size}
\SetKwData{MAXBLOCKSIZE}{maximum block size}
\SetKwData{MINFRAMESIZE}{minimum frame size}
\SetKwData{MAXFRAMESIZE}{maximum frame size}
\SetKwData{SAMPLERATE}{sample rate}
\SetKwData{CHANNELS}{channels}
\SetKwData{BPS}{bits per sample}
\SetKwData{TOTALFRAMES}{total PCM frames}
\SetKwData{MDSUM}{MD5 sum}
\SetKwData{STREAMINFO}{STREAMINFO}
\Repeat{$\LAST = 1$}{
  $\LAST \leftarrow$ \READ 1 unsigned bit\;
  $\TYPE \leftarrow$ \READ 7 unsigned bits\;
  $\SIZE \leftarrow$ \READ 24 unsigned bits\;
  \eIf(\tcc*[f]{read STREAMINFO metadata block}){$\TYPE = 0$}{
    \begin{tabular}{rcl}
      \MINBLOCKSIZE & $\leftarrow$ & \READ 16 unsigned bits\; \\
      \MAXBLOCKSIZE & $\leftarrow$ & \READ 16 unsigned bits\; \\
      \MINFRAMESIZE & $\leftarrow$ & \READ 24 unsigned bits\; \\
      \MAXFRAMESIZE & $\leftarrow$ & \READ 24 unsigned bits\; \\
      \SAMPLERATE & $\leftarrow$ & \READ 20 unsigned bits\; \\
      \CHANNELS & $\leftarrow$ & (\READ 3 unsigned bits) + 1\; \\
      \BPS & $\leftarrow$ & (\READ 5 unsigned bits) + 1\; \\
      \TOTALFRAMES & $\leftarrow$ & \READ 36 unsigned bits\; \\
      \MDSUM & $\leftarrow$ & \READ 16 bytes\;
    \end{tabular}
  }(\tcc*[f]{skip other metadata blocks}){
    \SKIP \SIZE bytes\;
  }
}
\Return $\text{\STREAMINFO} \leftarrow \left\lbrace\begin{tabular}{l}
\MINBLOCKSIZE \\
\MAXBLOCKSIZE \\
\MINFRAMESIZE \\
\MAXFRAMESIZE \\
\SAMPLERATE \\
\CHANNELS \\
\BPS \\
\TOTALFRAMES \\
\MDSUM \\
\end{tabular}\right.$
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{flac/figures/metadata.pdf}
\end{figure}

\clearpage

For example, given the metadata bytes:
\begin{figure}[h]
\includegraphics{flac/figures/block_header.pdf}
\end{figure}
\par
\noindent
\begin{tabular}{rcrcl}
\textsf{last} & $\leftarrow$ & \texttt{0x1} & = & is last metadata block \\
\textsf{size} & $\leftarrow$ & \texttt{0x0} & = & METADATA block \\
\textsf{type} & $\leftarrow$ & \texttt{0x22} & = & 34 bytes \\
\textsf{minimum block size} & $\leftarrow$ & \texttt{0x0100} & = & 4096 samples \\
\textsf{maximum block size} & $\leftarrow$ & \texttt{0x0100} & = & 4096 samples \\
\textsf{minimum frame size} & $\leftarrow$ & \texttt{0x00000C} & = & 12 bytes \\
\textsf{maximum frame size} & $\leftarrow$ & \texttt{0x00000C} & = & 12 bytes \\
\textsf{sample rate} & $\leftarrow$ & \texttt{0xAC44} & = & 44100Hz \\
\textsf{channels} & $\leftarrow$ & \texttt{0x1} & = & 1 (+ 1) = 2 \\
\textsf{bits per sample} & $\leftarrow$ & \texttt{0xF} & = & 15 (+ 1) = 16 \\
\textsf{total PCM frames} & $\leftarrow$ & \texttt{0x32} & = & 50 \\
\textsf{MD5 sum} & $\leftarrow$ & \multicolumn{3}{l}{\texttt{6D0BB00954CEB7FBEE436BB55A8397A9}} \\
\end{tabular}

\clearpage

\subsection{Decoding a FLAC Frame}
\label{flac:decode_frame}
\ALGORITHM{STREAMINFO values and the FLAC file stream}{decoded PCM samples}
\SetKwData{CHANNEL}{channel}
\SetKwData{CHANNELCOUNT}{channel count}
\hyperref[flac:read_frame_header]{read frame header to determine channel count, assignment and bits-per-sample}\;
\ForEach{\CHANNEL \IN \CHANNELCOUNT}{
  \hyperref[flac:decode_subframe]{decode subframe to PCM samples based on its effective bits-per-sample}\;
}
byte-align file stream\;
\hyperref[flac:verify_crc16]{verify frame's CRC-16 checksum}\;
\hyperref[flac:recombine_subframes]{recombine subframes based on the frame's channel assignment}\;
\Return samples\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{flac/figures/frames.pdf}
\end{figure}

\clearpage

\subsection{Reading a FLAC Frame Header}
\label{flac:read_frame_header}
{\relsize{-1}
\ALGORITHM{STREAMINFO values and the FLAC file stream}{stream information and subframe decoding parameters}
\SetKwData{SYNCCODE}{sync code}
\SetKwData{BLOCKINGSTRATEGY}{blocking strategy}
\SetKwData{ENCODEDBLOCKSIZE}{encoded block size}
\SetKwData{ENCODEDSAMPLERATE}{encoded sample rate}
\SetKwData{ENCODEDCHANNELS}{encoded channels}
\SetKwData{ENCODEDBPS}{encoded bits per sample}
\SetKwData{FRAMENUMBER}{frame number}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SAMPLERATE}{sample rate}
\SetKwData{BPS}{bits per sample}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{CRC}{CRC-8}
\SetKwData{FRAMEHEADER}{frame header}
\begin{tabular}{rcl}
\SYNCCODE & $\leftarrow$ & \READ 14 unsigned bits\; \\
& & \ASSERT $\text{\SYNCCODE} = \texttt{0x3FFE}$\; \\
& & \SKIP 1 bit\; \\
\BLOCKINGSTRATEGY & $\leftarrow$ & \READ 1 unsigned bit\; \\
\ENCODEDBLOCKSIZE & $\leftarrow$ & \READ 4 unsigned bits\; \\
\ENCODEDSAMPLERATE & $\leftarrow$ & \READ 4 unsigned bits\; \\
\ENCODEDCHANNELS & $\leftarrow$ & \READ 4 unsigned bits\; \\
\ENCODEDBPS & $\leftarrow$ & \READ 3 unsigned bits\; \\
& & \SKIP 1 bit\; \\
\FRAMENUMBER & $\leftarrow$ & \READ UTF-8 value\; \\
\BLOCKSIZE & $\leftarrow$ & decode \ENCODEDBLOCKSIZE\; \\
\SAMPLERATE & $\leftarrow$ & decode \ENCODEDSAMPLERATE\; \\
\BPS & $\leftarrow$ & decode \ENCODEDBPS\; \\
\CHANNELCOUNT & $\leftarrow$ & decode \ENCODEDCHANNELS\; \\
\CRC & $\leftarrow$ & \READ 8 unsigned bits\; \\
& & \hyperref[flac:verify_crc8]{verify \CRC}\; \\
\end{tabular}\;
\BlankLine
\Return $\text{\FRAMEHEADER} \leftarrow \left\lbrace\begin{tabular}{l}
\BLOCKSIZE \\
\SAMPLERATE \\
\BPS \\
\ENCODEDCHANNELS \\
\CHANNELCOUNT \\
\end{tabular}\right.$\;
\EALGORITHM
}

\subsubsection{Reading UTF-8 Frame Number}
{\relsize{-1}
\ALGORITHM{FLAC file stream}{UTF-8 value as unsigned integer}
\SetKwData{TOTALBYTES}{total bytes}
\SetKwData{VALUE}{value}
\SetKwData{CONTINUATIONHEADER}{continuation header}
\SetKwData{CONTINUATIONBITS}{continuation bits}
$\TOTALBYTES \leftarrow$ \UNARY with stop bit 0\;
$\VALUE \leftarrow$ \READ (7 - $\TOTALBYTES$) unsigned bits\;
\While{$\TOTALBYTES > 0$}{
  $\CONTINUATIONHEADER \leftarrow$ \READ 2 unsigned bits\;
  \ASSERT $\CONTINUATIONHEADER = 2$\;
  $\CONTINUATIONBITS \leftarrow$ \READ 6 unsigned bits\;
  $\VALUE \leftarrow (\VALUE \times 2 ^ 6) + \CONTINUATIONBITS$\;
  $\TOTALBYTES \leftarrow \TOTALBYTES - 1$\;
}
\Return \VALUE\;
\EALGORITHM
}
For example, given the UTF-8 bytes \texttt{E1 82 84}:
\par
\begin{wrapfigure}[5]{l}{2.375in}
\includegraphics{flac/figures/utf8.pdf}
\end{wrapfigure}
\begin{align*}
\text{UTF-8 value} &= \texttt{0001 000010 000100} \\
&= \texttt{0001 0000 1000 0100} \\
&= \texttt{0x1084} \\
&= 4228
\end{align*}

\clearpage

\subsubsection{Decoding Block Size}
{\relsize{-1}
\begin{tabular}{rl||rl}
encoded & block size (in samples) &
encoded & block size \\
\hline
\texttt{0000} & maximum block size from STREAMINFO &
\texttt{1000} & 256 \\
\texttt{0001} & 192 &
\texttt{1001} & 512 \\
\texttt{0010} & 576 &
\texttt{1010} & 1024 \\
\texttt{0011} & 1152 &
\texttt{1011} & 2048 \\
\texttt{0100} & 2304 &
\texttt{1100} & 4096 \\
\texttt{0101} & 4608 &
\texttt{1101} & 8192 \\
\texttt{0110} & (\textbf{read} 8 unsigned bits) + 1 &
\texttt{1110} & 16384 \\
\texttt{0111} & (\textbf{read} 16 unsigned bits) + 1 &
\texttt{1111} & 32768 \\
\end{tabular}
}

\subsubsection{Decoding Sample Rate}
{\relsize{-1}
\begin{tabular}{rl||rl}
encoded & sample rate (in Hz) &
encoded & sample rate \\
\hline
\texttt{0000} & from STREAMINFO &
\texttt{1000} & 32000 \\
\texttt{0001} & 88200 &
\texttt{1001} & 44100 \\
\texttt{0010} & 176400 &
\texttt{1010} & 48000 \\
\texttt{0011} & 192000 &
\texttt{1011} & 96000 \\
\texttt{0100} & 8000 &
\texttt{1100} & (\textbf{read} 8 unsigned bits) $\times$ 1000 \\
\texttt{0101} & 16000 &
\texttt{1101} & \textbf{read} 16 unsigned bits \\
\texttt{0110} & 22050 &
\texttt{1110} & (\textbf{read} 16 unsigned bits) $\times$ 10 \\
\texttt{0111} & 24000 &
\texttt{1111} & invalid \\
\end{tabular}
}

\subsubsection{Decoding Bits per Sample}
{\relsize{-1}
\begin{tabular}{rl||rl}
encoded & bits-per-sample &
encoded & bits-per-sample \\
\hline
\texttt{000} & from STREAMINFO &
\texttt{100} & 16 \\
\texttt{001} & 8 &
\texttt{101} & 20 \\
\texttt{010} & 12 &
\texttt{110} & 24 \\
\texttt{011} & invalid &
\texttt{111} & invalid \\
\end{tabular}
}

\subsubsection{Decoding Channel Count and Assignment}
{\relsize{-1}
\begin{tabular}{rrl}
& channel & \\
encoded & count & channel assignment \\
\hline
\texttt{0000} & 1 & front Center \\
\texttt{0001} & 2 & front Left, front Right \\
\texttt{0010} & 3 & front Left, front Right, front Center \\
\texttt{0011} & 4 & front Left, front Right, back Left, back Right \\
\texttt{0100} & 5 & fL, fR, fC, back/surround left, back/surround right \\
\texttt{0101} & 6 & fL, fR, fC, LFE, back/surround left, back/surround right \\
\texttt{0110} & 7 & undefined \\
\texttt{0111} & 8 & undefined \\
\texttt{1000} & 2 & front Left, Difference \\
\texttt{1001} & 2 & Difference, front Right \\
\texttt{1010} & 2 & Average, Difference \\
\texttt{1011} & & reserved \\
\texttt{1100} & & reserved \\
\texttt{1101} & & reserved \\
\texttt{1110} & & reserved \\
\texttt{1111} & & reserved \\
\end{tabular}
}

\subsubsection{Frame Header Decoding Example}
\begin{figure}[h]
\includegraphics{flac/figures/header-example.pdf}
\end{figure}
{\relsize{-1}
\begin{tabular}{rcl}
\textsf{sync code} & = & \texttt{0x3FFE} \\
\textsf{encoded block size} & = & \texttt{1100b} \\
\textsf{encoded sample rate} & = & \texttt{1001b} \\
\textsf{encoded channels} & = & \texttt{0001b} \\
\textsf{encoded bps} & = & \texttt{100b} \\
\textsf{frame number} & = & 0 \\
\textsf{block size} & = & 4096 samples \\
\textsf{sample rate} & = & 44100Hz \\
\textsf{bits per sample} & = & 16 \\
\textsf{channel count} & = & 2 \\
\textsf{channel assignment} & = & front left, front right
\end{tabular}
}
\subsubsection{Calculating Frame Header CRC-8}
\label{flac:verify_crc8}
Given a header byte and previous CRC-8 checksum,
or 0 as an initial value:
\begin{equation*}
\text{checksum}_i = \texttt{CRC8}(byte\xor\text{checksum}_{i - 1})
\end{equation*}
\begin{table}[h]
{\relsize{-3}\ttfamily
\begin{tabular}{|r||r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|}
\hline
 & 0x?0 & 0x?1 & 0x?2 & 0x?3 & 0x?4 & 0x?5 & 0x?6 & 0x?7 & 0x?8 & 0x?9 & 0x?A & 0x?B & 0x?C & 0x?D & 0x?E & 0x?F \\
\hline
0x0? & 0x00 & 0x07 & 0x0E & 0x09 & 0x1C & 0x1B & 0x12 & 0x15 & 0x38 & 0x3F & 0x36 & 0x31 & 0x24 & 0x23 & 0x2A & 0x2D \\
0x1? & 0x70 & 0x77 & 0x7E & 0x79 & 0x6C & 0x6B & 0x62 & 0x65 & 0x48 & 0x4F & 0x46 & 0x41 & 0x54 & 0x53 & 0x5A & 0x5D \\
0x2? & 0xE0 & 0xE7 & 0xEE & 0xE9 & 0xFC & 0xFB & 0xF2 & 0xF5 & 0xD8 & 0xDF & 0xD6 & 0xD1 & 0xC4 & 0xC3 & 0xCA & 0xCD \\
0x3? & 0x90 & 0x97 & 0x9E & 0x99 & 0x8C & 0x8B & 0x82 & 0x85 & 0xA8 & 0xAF & 0xA6 & 0xA1 & 0xB4 & 0xB3 & 0xBA & 0xBD \\
0x4? & 0xC7 & 0xC0 & 0xC9 & 0xCE & 0xDB & 0xDC & 0xD5 & 0xD2 & 0xFF & 0xF8 & 0xF1 & 0xF6 & 0xE3 & 0xE4 & 0xED & 0xEA \\
0x5? & 0xB7 & 0xB0 & 0xB9 & 0xBE & 0xAB & 0xAC & 0xA5 & 0xA2 & 0x8F & 0x88 & 0x81 & 0x86 & 0x93 & 0x94 & 0x9D & 0x9A \\
0x6? & 0x27 & 0x20 & 0x29 & 0x2E & 0x3B & 0x3C & 0x35 & 0x32 & 0x1F & 0x18 & 0x11 & 0x16 & 0x03 & 0x04 & 0x0D & 0x0A \\
0x7? & 0x57 & 0x50 & 0x59 & 0x5E & 0x4B & 0x4C & 0x45 & 0x42 & 0x6F & 0x68 & 0x61 & 0x66 & 0x73 & 0x74 & 0x7D & 0x7A \\
0x8? & 0x89 & 0x8E & 0x87 & 0x80 & 0x95 & 0x92 & 0x9B & 0x9C & 0xB1 & 0xB6 & 0xBF & 0xB8 & 0xAD & 0xAA & 0xA3 & 0xA4 \\
0x9? & 0xF9 & 0xFE & 0xF7 & 0xF0 & 0xE5 & 0xE2 & 0xEB & 0xEC & 0xC1 & 0xC6 & 0xCF & 0xC8 & 0xDD & 0xDA & 0xD3 & 0xD4 \\
0xA? & 0x69 & 0x6E & 0x67 & 0x60 & 0x75 & 0x72 & 0x7B & 0x7C & 0x51 & 0x56 & 0x5F & 0x58 & 0x4D & 0x4A & 0x43 & 0x44 \\
0xB? & 0x19 & 0x1E & 0x17 & 0x10 & 0x05 & 0x02 & 0x0B & 0x0C & 0x21 & 0x26 & 0x2F & 0x28 & 0x3D & 0x3A & 0x33 & 0x34 \\
0xC? & 0x4E & 0x49 & 0x40 & 0x47 & 0x52 & 0x55 & 0x5C & 0x5B & 0x76 & 0x71 & 0x78 & 0x7F & 0x6A & 0x6D & 0x64 & 0x63 \\
0xD? & 0x3E & 0x39 & 0x30 & 0x37 & 0x22 & 0x25 & 0x2C & 0x2B & 0x06 & 0x01 & 0x08 & 0x0F & 0x1A & 0x1D & 0x14 & 0x13 \\
0xE? & 0xAE & 0xA9 & 0xA0 & 0xA7 & 0xB2 & 0xB5 & 0xBC & 0xBB & 0x96 & 0x91 & 0x98 & 0x9F & 0x8A & 0x8D & 0x84 & 0x83 \\
0xF? & 0xDE & 0xD9 & 0xD0 & 0xD7 & 0xC2 & 0xC5 & 0xCC & 0xCB & 0xE6 & 0xE1 & 0xE8 & 0xEF & 0xFA & 0xFD & 0xF4 & 0xF3 \\
\hline
\end{tabular}
}
\end{table}
\begin{align*}
\text{checksum}_0 = \texttt{CRC8}(\texttt{FF}\xor\texttt{00}) = \texttt{F3} & &
\text{checksum}_3 = \texttt{CRC8}(\texttt{18}\xor\texttt{E6}) = \texttt{F4} \\
\text{checksum}_1 = \texttt{CRC8}(\texttt{F8}\xor\texttt{F3}) = \texttt{31} & &
\text{checksum}_4 = \texttt{CRC8}(\texttt{00}\xor\texttt{F4}) = \texttt{C2} \\
\text{checksum}_2 = \texttt{CRC8}(\texttt{C9}\xor\texttt{31}) = \texttt{E6} & &
\text{checksum}_5 = \texttt{CRC8}(\texttt{C2}\xor\texttt{C2}) = \texttt{00} \\
\end{align*}
Note that the final checksum (including the CRC-8 byte itself)
should always be 0.


\clearpage

\subsection{Decoding a FLAC Subframe}
\label{flac:decode_subframe}
{\relsize{-1}
\ALGORITHM{the frame's block size and bits per sample, the subframe's channel assignment and the FLAC file stream}{decoded signed PCM samples}
\SetKwData{TYPEORDER}{type/order}
\SetKwData{WASTEDBPS}{wasted BPS}
\SetKwData{EFFECTIVEBPS}{subframe's BPS}
\SetKwData{DIFFERENCE}{difference}
\SetKwData{ORDER}{order}
\SetKwData{SAMPLE}{sample}
\SetKwData{BLOCKSIZE}{block size}
\SKIP 1 bit\;
$\TYPEORDER \leftarrow$ \READ 6 unsigned bits\;
\eIf(\tcc*[f]{account for wasted bits}){$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\WASTEDBPS \leftarrow$ (\UNARY with stop bit 1) + 1\;
}{
  $\WASTEDBPS \leftarrow 0$\;
}
\eIf{subframe's channel assignment is \DIFFERENCE}{
  $\EFFECTIVEBPS \leftarrow \text{frame header's bits per sample} - \WASTEDBPS + 1$\;
}{
  $\EFFECTIVEBPS \leftarrow \text{frame header's bits per sample} - \WASTEDBPS$\;
}
\uIf{$\TYPEORDER = 0$}{
  \SAMPLE $\leftarrow$ \hyperref[flac:decode_constant]{decode CONSTANT subframe with \BLOCKSIZE, \EFFECTIVEBPS}\;
}
\uElseIf{$\TYPEORDER = 1$} {
  \SAMPLE $\leftarrow$ \hyperref[flac:decode_verbatim]{decode VERBATIM subframe with \BLOCKSIZE, \EFFECTIVEBPS}\;
}
\uElseIf{$8 \leq \TYPEORDER \leq 12$} {
  $\ORDER \leftarrow \TYPEORDER - 8$\;
  \SAMPLE $\leftarrow$ \hyperref[flac:decode_fixed]{decode FIXED subframe with \BLOCKSIZE, \EFFECTIVEBPS, \ORDER}\;
}
\uElseIf{$32 \leq \TYPEORDER \leq 63$} {
  $\ORDER \leftarrow \TYPEORDER - 31$\;
  \SAMPLE $\leftarrow$ \hyperref[flac:decode_lpc]{decode LPC subframe with \BLOCKSIZE, \EFFECTIVEBPS, \ORDER}\;
}
\Else {
  undefined subframe type error\;
}
\If(\tcc*[f]{prepend any wasted bits to each sample}){$\WASTEDBPS > 0$}{
  \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
    $\text{\SAMPLE}_i \leftarrow \text{\SAMPLE}_i \times 2 ^ {\WASTEDBPS}$\;
  }
}
\Return \SAMPLE\;
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{flac/figures/subframes.pdf}
\end{figure}

\clearpage

\subsubsection{Decoding CONSTANT Subframe}
\label{flac:decode_constant}
\ALGORITHM{the frame's block size, the subframe's bits per sample}{decoded signed PCM samples}
\SetKwData{CONSTANT}{constant}
\SetKwData{BPS}{subframe's BPS}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SAMPLE}{sample}
$\CONSTANT \leftarrow$ \READ (\BPS) signed bits\;
\For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
  $\text{\SAMPLE}_i \leftarrow \CONSTANT$\;
}
\Return \SAMPLE\;
\EALGORITHM
\begin{figure}[h]
  \includegraphics{flac/figures/constant.pdf}
\end{figure}

\subsubsection{Decoding VERBATIM Subframe}
\label{flac:decode_verbatim}
\ALGORITHM{the frame's block size, the subframe's bits per sample}{decoded signed PCM samples}
\SetKwData{BPS}{bits per sample}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SAMPLE}{sample}
\For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
  $\text{\SAMPLE}_i \leftarrow $ \READ (\BPS) signed bits\;
}
\Return \SAMPLE\;
\EALGORITHM
\begin{figure}[h]
\includegraphics{flac/figures/verbatim.pdf}
\end{figure}

\clearpage

\subsubsection{Decoding FIXED Subframe}
\label{flac:decode_fixed}
{\relsize{-1}
\ALGORITHM{the frame's block size, the subframe's bits per sample and predictor order}{decoded signed PCM samples}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{BPS}{subframe's BPS}
\SetKwData{ORDER}{order}
\SetKwData{SAMPLE}{sample}
\SetKwData{RESIDUAL}{residual}
\For(\tcc*[f]{warm-up samples}){$i \leftarrow 0$ \emph{\KwTo}\ORDER}{
  $\text{\SAMPLE}_i \leftarrow $ \READ (\BPS) signed bits\;
}
\BlankLine
$\RESIDUAL \leftarrow$ \hyperref[flac:decode_residual]{read residual block with frame's \BLOCKSIZE and subframe's \ORDER}\;
\BlankLine
\Switch{\ORDER}{
  \uCase{0} {
    \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
      $\text{\SAMPLE}_i \leftarrow \text{\RESIDUAL}_i$
    }
  }
  \uCase{1} {
    \For{$i \leftarrow 1$ \emph{\KwTo}\BLOCKSIZE}{
      $\text{\SAMPLE}_i \leftarrow \text{\SAMPLE}_{i - 1} + \text{\RESIDUAL}_{i - 1}$
    }
  }
  \uCase{2} {
    \For{$i \leftarrow 2$ \emph{\KwTo}\BLOCKSIZE}{
      $\text{\SAMPLE}_i \leftarrow (2 \times \text{\SAMPLE}_{i - 1}) - \text{\SAMPLE}_{i - 2} + \text{\RESIDUAL}_{i - 2}$
    }
  }
  \uCase{3} {
    \For{$i \leftarrow 3$ \emph{\KwTo}\BLOCKSIZE}{
      $\text{\SAMPLE}_i \leftarrow (3 \times \text{\SAMPLE}_{i - 1}) - (3 \times \text{\SAMPLE}_{i - 2}) + \text{\SAMPLE}_{i - 3} + \text{\RESIDUAL}_{i - 3}$
    }
  }
  \Case{4} {
    \For{$i \leftarrow 4$ \emph{\KwTo}\BLOCKSIZE}{
      $\text{\SAMPLE}_i \leftarrow (4 \times \text{\SAMPLE}_{i - 1}) - (6 \times \text{\SAMPLE}_{i - 2}) + (4 \times \text{\SAMPLE}_{i - 3}) - \text{\SAMPLE}_{i - 4} + \text{\RESIDUAL}_{i - 4}$
    }
  }
}
\Return \SAMPLE\;
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{flac/figures/fixed.pdf}
\end{figure}

\clearpage

\subsubsection{FIXED Subframe Decoding Example}

Given the subframe bytes of a 16 bits per sample stream\footnote{Decoding the residual block is explained on page \pageref{flac:decode_residual}}:
\begin{figure}[h]
\includegraphics{flac/figures/fixed-parse.pdf}
\end{figure}
\begin{align*}
\text{subframe type} &\leftarrow \text{FIXED} \\
\text{subframe order} &\leftarrow 1 \\
\text{wasted BPS} &\leftarrow 0 \\
\text{warm-up sample} &\leftarrow \texttt{[37]} \\
\end{align*}
\begin{center}
\begin{tabular}{r||r|>{$}r<{$}}
$i$ & $\textsf{residual}_{i - 1}$ & \textsf{sample}_i \\
\hline
0 & & 37 \\
1 & -2 & 37 - 2 = 35 \\
2 & 3 & 35 + 3 = 38 \\
3 & -1 & 38 - 1 = 37 \\
4 & -5 & 37 - 5 = 32 \\
5 & 1 & 32 + 1 = 33 \\
6 & -5 & 33 - 5 = 27 \\
7 & 4 & 27 + 4 = 31 \\
8 & -2 & 31 - 2 = 29 \\
9 & -3 & 29 - 3 = 26 \\
10 & 1 & 26 + 1 = 27 \\
\end{tabular}
\end{center}

\clearpage

\subsubsection{Decoding LPC Subframe}
\label{flac:decode_lpc}
{\relsize{-1}
\ALGORITHM{the frame's block size, the subframe's bits per sample and predictor order}{decoded signed PCM samples}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{BPS}{subframe's BPS}
\SetKwData{ORDER}{order}
\SetKwData{QLPPREC}{QLP precision}
\SetKwData{QLPSHIFT}{QLP shift needed}
\SetKwData{COEFF}{QLP coefficient}
\SetKwData{RESIDUAL}{residual}
\SetKwData{SAMPLE}{sample}
\SetKwFunction{MAX}{max}
\For(\tcc*[f]{warm-up samples}){$i \leftarrow 0$ \emph{\KwTo}\ORDER}{
  $\text{\SAMPLE}_i \leftarrow $ \READ (\BPS) signed bits\;
}
$\QLPPREC \leftarrow$ (\READ 4 unsigned bits) + 1\;
$\QLPSHIFT \leftarrow \MAX(\text{\READ 5 signed bits}~,~0)$\footnote{negative shifts are no-ops in the decoder}\;
\For{$i \leftarrow 0$ \emph{\KwTo}\ORDER}{
  $\text{\COEFF}_i \leftarrow$ \READ (\QLPPREC) signed bits\;
}
\BlankLine
$\RESIDUAL \leftarrow$ \hyperref[flac:decode_residual]{read residual block with frame's \BLOCKSIZE and subframe's \ORDER}\;
\BlankLine
\For{$i \leftarrow \ORDER$ \emph{\KwTo}\BLOCKSIZE}{
  $\text{\SAMPLE}_i \leftarrow \left\lfloor \frac{\overset{\ORDER - 1}{\underset{j = 0}{\sum}}
    \text{\COEFF}_j \times \text{\SAMPLE}_{i - j - 1} } {2 ^ \text{\QLPSHIFT}}\right\rfloor + \text{\RESIDUAL}_{i - \ORDER}$\;
}
\Return \SAMPLE\;
\EALGORITHM
}
\begin{figure}[h]
\includegraphics{flac/figures/lpc.pdf}
\end{figure}

\clearpage

\subsubsection{LPC Subframe Decoding Example}

\begin{figure}[h]
\includegraphics{flac/figures/lpc-parse.pdf}
\end{figure}
{\relsize{-1}
  \begin{align*}
    \text{subframe type} &\leftarrow \text{LPC} \\
    \text{subframe order} &\leftarrow 3 \\
    \text{wasted BPS} &\leftarrow 0 \\
    \text{warm-up sample} &\leftarrow \texttt{[43, 48, 50]} \\
    \text{QLP precision} &\leftarrow 11 + 1 = 12 \\
    \text{QLP shift needed} &\leftarrow 10 \\
    \text{QLP coefficient} &\leftarrow \texttt{[1451, -323, -110]}
  \end{align*}
  \begin{center}
    \begin{tabular}{r||r|>{$}r<{$}}
      $i$ & $\textsf{residual}_{i - 3}$ & \textsf{sample}_i \\
      \hline
      0 & & 43 \\
      1 & & 48 \\
      2 & & 50 \\
      3 & 4 & \left\lfloor\frac{(1451 \times 50) + (-323 \times 48) + (-110 \times 43)}{2 ^ {10}}\right\rfloor + 4 = 55 \\ [1ex]
      4 & 0 & \left\lfloor\frac{(1451 \times 55) + (-323 \times 50) + (-110 \times 48)}{2 ^ {10}}\right\rfloor + 0 = 57 \\ [1ex]
      5 & 1 & \left\lfloor\frac{(1451 \times 57) + (-323 \times 55) + (-110 \times 50)}{2 ^ {10}}\right\rfloor + 1 = 59 \\ [1ex]
      6 & -2 & \left\lfloor\frac{(1451 \times 59) + (-323 \times 57) + (-110 \times 55)}{2 ^ {10}}\right\rfloor - 2 = 57 \\ [1ex]
      7 & -3 & \left\lfloor\frac{(1451 \times 57) + (-323 \times 59) + (-110 \times 57)}{2 ^ {10}}\right\rfloor - 3 = 53 \\
    \end{tabular}
  \end{center}
}

\clearpage

\subsubsection{Decoding Residual Block}
\label{flac:decode_residual}
{\relsize{-1}
\ALGORITHM{the frame's block size and predictor order}{decoded signed residual values}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{CODING}{coding method}
\SetKwData{PORDER}{partition order}
\SetKwData{PCOUNT}{partition residual count}
\SetKwData{ORDER}{predictor order}
\SetKwData{RESIDUAL}{residual}
\SetKwData{RICE}{Rice}
\SetKwData{ESCAPE}{escape code}
\SetKwData{MSB}{MSB}
\SetKwData{LSB}{LSB}
\SetKwData{UNSIGNED}{unsigned}
\SetKw{AND}{and}
\SetKw{OR}{or}
$\CODING \leftarrow$ \READ 2 unsigned bits\;
$\PORDER \leftarrow$ \READ 4 unsigned bits\;
$i \leftarrow 0$\;
\BlankLine
\For(\tcc*[f]{read residual partitions}){$p \leftarrow 0$ \emph{\KwTo}$2 ^ {\text{\PORDER}}$}{
  \uIf{$\text{\CODING} = 0$}{
    $\text{\RICE}_p \leftarrow$ \READ 4 unsigned bits\;
  }
  \uElseIf{$\text{\CODING} = 1$}{
    $\text{\RICE}_p \leftarrow$ \READ 5 unsigned bits\;
  }
  \Else{
    undefined residual coding method error\;
  }
  \eIf{p = 0}{
    $\text{\PCOUNT}_p \leftarrow \lfloor\text{\BLOCKSIZE} \div 2 ^ {\PORDER}\rfloor - \text{\ORDER}$
  }{
    $\text{\PCOUNT}_p \leftarrow \lfloor\text{\BLOCKSIZE} \div 2 ^ {\PORDER}\rfloor$
  }
  \eIf{$((\text{\CODING} = 0)~\text{\AND}~(\text{\RICE}_p = 15))$ \OR
    $((\text{\CODING} = 1)~\text{\AND}~(\text{\RICE}_p = 31))$}{
    $\text{\ESCAPE}_p \leftarrow$ \READ 5 unsigned bits\;
    \For{$j \leftarrow 0$ \emph{\KwTo}$\text{\PCOUNT}_p$}{
      $\text{\RESIDUAL}_i \leftarrow$ \READ $\text{\ESCAPE}_p$ signed bits\;
      $i \leftarrow i + 1$\;
    }
  }{
    \For{$j \leftarrow 0$ \emph{\KwTo}$\text{\PCOUNT}_p$} {
      $\text{\MSB}_i \leftarrow$ \UNARY with stop bit 1\;
      $\text{\LSB}_i \leftarrow$ \READ $\text{\RICE}_p$ unsigned bits\;
      $\text{\UNSIGNED}_i \leftarrow \text{\MSB}_i \times 2 ^ {\text{\RICE}_p} + \text{\LSB}_i$\;
      \eIf(\tcc*[f]{apply sign bit}){$(\text{\UNSIGNED}_i \bmod 2) = 0$}{
        $\text{\RESIDUAL}_i \leftarrow \text{\UNSIGNED}_i \div 2$\;
      }{
        $\text{\RESIDUAL}_i \leftarrow -\lfloor \text{\UNSIGNED}_i \div 2 \rfloor - 1$\;
      }
      $i \leftarrow i + 1$\;
    }
  }
}
\Return \RESIDUAL\;
\EALGORITHM
}
\begin{figure}[h]
  \includegraphics{flac/figures/residual.pdf}
\end{figure}

\clearpage

\subsubsection{Residual Block Decoding Example}
\begin{figure}[h]
\includegraphics{flac/figures/residual-parse.pdf}
\end{figure}
\begin{align*}
  \textsf{coding method} &\leftarrow 0 \\
  \textsf{partition order} &\leftarrow 0 \\
  \textsf{Rice parameter} &\leftarrow 2 \\
\end{align*}
\begin{center}

  {\renewcommand{\arraystretch}{1.25}
    \begin{tabular}{r||rr|>{$}r<{$}|>{$}r<{$}}
    $i$ & $\textsf{MSB}_i$ & $\textsf{LSB}_i$ & \textsf{unsigned}_i & \textsf{residual}_i \\
    \hline
    0 & 0 & 3 & 0 \times 2 ^ 2 + 3 = 3 & -\lfloor 3 \div 2\rfloor - 1 = -2 \\
    1 & 1 & 2 & 1 \times 2 ^ 2 + 2 = 6 & 6 \div 2 = 3 \\
    2 & 0 & 1 & 0 \times 2 ^ 2 + 1 = 1 & -\lfloor 1 \div 2\rfloor - 1 = -1 \\
    3 & 2 & 1 & 2 \times 2 ^ 2 + 1 = 9 & -\lfloor 9 \div 2\rfloor - 1 = -5 \\
    4 & 0 & 2 & 0 \times 2 ^ 2 + 2 = 2 & 2 \div 2 = 1 \\
    5 & 2 & 1 & 2 \times 2 ^ 2 + 1 = 9 & -\lfloor 9 \div 2\rfloor - 1 = -5 \\
    6 & 2 & 0 & 2 \times 2 ^ 2 + 0 = 8 & 8 \div 2 = 4 \\
    7 & 0 & 3 & 0 \times 2 ^ 2 + 3 = 3 & -\lfloor 3 \div 2\rfloor - 1 = -2 \\
    8 & 1 & 1 & 1 \times 2 ^ 2 + 1 = 5 & -\lfloor 5 \div 2\rfloor - 1 = -3 \\
    9 & 0 & 2 & 0 \times 2 ^ 2 + 2 = 2 & 2 \div 2 = 1 \\
  \end{tabular}}
\end{center}
\par
\noindent
for a final set of residuals: \texttt{[-2, 3, -1, -5, 1, -5, 4, -2, -3, 1]}

\clearpage

\subsection{Calculating Frame CRC-16}
\label{flac:verify_crc16}
CRC-16 is used to checksum the entire FLAC frame, including the header
and any padding bits after the final subframe.
Given a byte of input and the previous CRC-16 checksum,
or 0 as an initial value, the current checksum can be calculated as follows:
\begin{equation}
\text{checksum}_i = \texttt{CRC16}(byte\xor(\text{checksum}_{i - 1} \gg 8 ))\xor(\text{checksum}_{i - 1} \ll 8)
\end{equation}
\par
\noindent
and the checksum is always truncated to 16-bits.
\begin{table}[h]
{\relsize{-3}\ttfamily
\begin{tabular}{|r||r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|}
\hline
 & 0x?0 & 0x?1 & 0x?2 & 0x?3 & 0x?4 & 0x?5 & 0x?6 & 0x?7 & 0x?8 & 0x?9 & 0x?A & 0x?B & 0x?C & 0x?D & 0x?E & 0x?F \\
\hline
0x0? & 0000 & 8005 & 800f & 000a & 801b & 001e & 0014 & 8011 & 8033 & 0036 & 003c & 8039 & 0028 & 802d & 8027 & 0022 \\
0x1? & 8063 & 0066 & 006c & 8069 & 0078 & 807d & 8077 & 0072 & 0050 & 8055 & 805f & 005a & 804b & 004e & 0044 & 8041 \\
0x2? & 80c3 & 00c6 & 00cc & 80c9 & 00d8 & 80dd & 80d7 & 00d2 & 00f0 & 80f5 & 80ff & 00fa & 80eb & 00ee & 00e4 & 80e1 \\
0x3? & 00a0 & 80a5 & 80af & 00aa & 80bb & 00be & 00b4 & 80b1 & 8093 & 0096 & 009c & 8099 & 0088 & 808d & 8087 & 0082 \\
0x4? & 8183 & 0186 & 018c & 8189 & 0198 & 819d & 8197 & 0192 & 01b0 & 81b5 & 81bf & 01ba & 81ab & 01ae & 01a4 & 81a1 \\
0x5? & 01e0 & 81e5 & 81ef & 01ea & 81fb & 01fe & 01f4 & 81f1 & 81d3 & 01d6 & 01dc & 81d9 & 01c8 & 81cd & 81c7 & 01c2 \\
0x6? & 0140 & 8145 & 814f & 014a & 815b & 015e & 0154 & 8151 & 8173 & 0176 & 017c & 8179 & 0168 & 816d & 8167 & 0162 \\
0x7? & 8123 & 0126 & 012c & 8129 & 0138 & 813d & 8137 & 0132 & 0110 & 8115 & 811f & 011a & 810b & 010e & 0104 & 8101 \\
0x8? & 8303 & 0306 & 030c & 8309 & 0318 & 831d & 8317 & 0312 & 0330 & 8335 & 833f & 033a & 832b & 032e & 0324 & 8321 \\
0x9? & 0360 & 8365 & 836f & 036a & 837b & 037e & 0374 & 8371 & 8353 & 0356 & 035c & 8359 & 0348 & 834d & 8347 & 0342 \\
0xA? & 03c0 & 83c5 & 83cf & 03ca & 83db & 03de & 03d4 & 83d1 & 83f3 & 03f6 & 03fc & 83f9 & 03e8 & 83ed & 83e7 & 03e2 \\
0xB? & 83a3 & 03a6 & 03ac & 83a9 & 03b8 & 83bd & 83b7 & 03b2 & 0390 & 8395 & 839f & 039a & 838b & 038e & 0384 & 8381 \\
0xC? & 0280 & 8285 & 828f & 028a & 829b & 029e & 0294 & 8291 & 82b3 & 02b6 & 02bc & 82b9 & 02a8 & 82ad & 82a7 & 02a2 \\
0xD? & 82e3 & 02e6 & 02ec & 82e9 & 02f8 & 82fd & 82f7 & 02f2 & 02d0 & 82d5 & 82df & 02da & 82cb & 02ce & 02c4 & 82c1 \\
0xE? & 8243 & 0246 & 024c & 8249 & 0258 & 825d & 8257 & 0252 & 0270 & 8275 & 827f & 027a & 826b & 026e & 0264 & 8261 \\
0xF? & 0220 & 8225 & 822f & 022a & 823b & 023e & 0234 & 8231 & 8213 & 0216 & 021c & 8219 & 0208 & 820d & 8207 & 0202 \\
\hline
\end{tabular}
}
\end{table}
\par
\noindent
For example, given the frame bytes:
\texttt{FF F8 CC 1C 00 C0 EB 00 00 00 00 00 00 00 00},
the frame's CRC-16 can be calculated:
{\relsize{-2}
\begin{align*}
\CRCSIXTEEN{0}{0xFF}{0x0000}{0xFF}{0x0000}{0x0202} \\
\CRCSIXTEEN{1}{0xF8}{0x0202}{0xFA}{0x0200}{0x001C} \\
\CRCSIXTEEN{2}{0xCC}{0x001C}{0xCC}{0x1C00}{0x1EA8} \\
\CRCSIXTEEN{3}{0x1C}{0x1EA8}{0x02}{0xA800}{0x280F} \\
\CRCSIXTEEN{4}{0x00}{0x280F}{0x28}{0x0F00}{0x0FF0} \\
\CRCSIXTEEN{5}{0xC0}{0x0FF0}{0xCF}{0xF000}{0xF2A2} \\
\CRCSIXTEEN{6}{0xEB}{0xF2A2}{0x19}{0xA200}{0x2255} \\
\CRCSIXTEEN{7}{0x00}{0x2255}{0x22}{0x5500}{0x55CC} \\
\CRCSIXTEEN{8}{0x00}{0x55CC}{0x55}{0xCC00}{0xCDFE} \\
\CRCSIXTEEN{9}{0x00}{0xCDFE}{0xCD}{0xFE00}{0x7CAD} \\
\CRCSIXTEEN{10}{0x00}{0x7CAD}{0x7C}{0xAD00}{0x2C0B} \\
\CRCSIXTEEN{11}{0x00}{0x2C0B}{0x2C}{0x0B00}{0x8BEB} \\
\CRCSIXTEEN{12}{0x00}{0x8BEB}{0x8B}{0xEB00}{0xE83A} \\
\CRCSIXTEEN{13}{0x00}{0xE83A}{0xE8}{0x3A00}{0x3870} \\
\CRCSIXTEEN{14}{0x00}{0x3870}{0x38}{0x7000}{0xF093} \\
\intertext{Thus, the next two bytes after the final subframe should be
\texttt{0xF0} and \texttt{0x93}.
Again, when the checksum bytes are run through the checksumming procedure:}
\CRCSIXTEEN{15}{0xF0}{0xF093}{0x00}{0x9300}{0x9300} \\
\CRCSIXTEEN{16}{0x93}{0x9300}{0x00}{0x0000}{0x0000}
\end{align*}
the result will also always be 0, just as in the CRC-8.
}

\clearpage

\subsection{Recombining Subframes}
\label{flac:recombine_subframes}
\ALGORITHM{the frame's block size and channel assignment, a set of decoded subframe samples\footnote{$\textsf{subframe}_{x~y}$ indicates the $y$th sample in subframe $x$}}{a list of signed PCM frames per channel}
\SetKwData{ENCODEDCHANNELS}{encoded channels}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SUBFRAME}{subframe}
\SetKwData{CHANNEL}{channel}
\uIf(\tcc*[f]{independent}){$0 \leq \ENCODEDCHANNELS \leq 7$}{
 \CHANNELCOUNT $\leftarrow \ENCODEDCHANNELS + 1$\;
 \For{$c \leftarrow 0$ \emph{\KwTo}\CHANNELCOUNT}{
   \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
     $\text{\CHANNEL}_{c~i} \leftarrow \text{\SUBFRAME}_{c~i}$
   }
 }
}
\uElseIf(\tcc*[f]{left-difference}){$\ENCODEDCHANNELS = 8$}{
  \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
    $\text{\CHANNEL}_{0~i} \leftarrow \text{\SUBFRAME}_{0~i}$\;
    $\text{\CHANNEL}_{1~i} \leftarrow \text{\SUBFRAME}_{0~i} - \text{\SUBFRAME}_{1~i}$\;
  }
}
\uElseIf(\tcc*[f]{difference-right}){$\ENCODEDCHANNELS = 9$}{
  \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
    $\text{\CHANNEL}_{0~i} \leftarrow \text{\SUBFRAME}_{0~i} + \text{\SUBFRAME}_{1~i}$\;
    $\text{\CHANNEL}_{1~i} \leftarrow \text{\SUBFRAME}_{1~i}$\;
  }
}
\ElseIf(\tcc*[f]{average-difference}){$\ENCODEDCHANNELS = 10$}{
  \For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
    $\text{\CHANNEL}_{0~i} \leftarrow \lfloor(((\text{\SUBFRAME}_{0~i} \times 2) + (\text{\SUBFRAME}_{1~i} \bmod 2)) + \text{\SUBFRAME}_{1~i}) \div 2\rfloor$\;
      $\text{\CHANNEL}_{1~i} \leftarrow \lfloor(((\text{\SUBFRAME}_{0~i} \times 2) + (\text{\SUBFRAME}_{1~i} \bmod 2)) - \text{\SUBFRAME}_{1~i}) \div 2\rfloor$\;
  }
}
\Return \CHANNEL\;
\EALGORITHM

\clearpage

\subsection{Updating Stream MD5 Sum}
\label{flac:update_md5}
\ALGORITHM{the frame's signed PCM samples\footnote{$channel_{c~i}$ indicates the $i$th sample in channel $c$}}{the stream's updated MD5 sum}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{CHANNEL}{channel}
\For{$i \leftarrow 0$ \emph{\KwTo}\BLOCKSIZE}{
  \For{$c \leftarrow 0$ \emph{\KwTo}\CHANNELCOUNT}{
    bytes $\leftarrow \text{\CHANNEL}_{c~i}$ as signed, little-endian bytes\;
    update stream's MD5 sum with bytes\;
  }
}
\Return stream's MD5 sum\;
\EALGORITHM
\vskip .25in
\par
\noindent
For example, given a 16 bits per sample stream with the signed sample values:
\begin{table}[h]
\begin{tabular}{r|rr}
$i$ & $\textsf{channel}_{0~i}$ & $\textsf{channel}_{1~i}$ \\
\hline
0 & 1 & -1 \\
1 & 2 & -2 \\
2 & 3 & -3 \\
\end{tabular}
\end{table}
\par
\noindent
are translated to the bytes:
\begin{table}[h]
\begin{tabular}{r|rr}
$i$ & $\textsf{channel}_{0~i}$ & $\textsf{channel}_{1~i}$ \\
\hline
0 & \texttt{01 00} & \texttt{FF FF} \\
1 & \texttt{02 00} & \texttt{FE FF} \\
2 & \texttt{03 00} & \texttt{FD FF} \\
\end{tabular}
\end{table}
\par
\noindent
and combined as:
\vskip .15in
\par
\noindent
\texttt{01 00 FF FF 02 00 FE FF 03 00 FD FF}
\vskip .15in
\par
\noindent
whose MD5 sum is:
\vskip .15in
\par
\noindent
\texttt{E7482f6462B27EE04EADC079291C79E9}
