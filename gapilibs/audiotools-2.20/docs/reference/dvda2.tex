%This work is licensed under the
%Creative Commons Attribution-Share Alike 3.0 United States License.
%To view a copy of this license, visit
%http://creativecommons.org/licenses/by-sa/3.0/us/ or send a letter to
%Creative Commons,
%171 Second Street, Suite 300,
%San Francisco, California, 94105, USA.

\chapter{DVD-Audio}
DVD-Audio is a format for delivering hi-fidelity, multichannel
audio on DVD media.
A DVD-Audio's \texttt{AUDIO\_TS} directory contains the
relevant data needed for decoding, spread into a lot of files
whose names are more than a little cryptic at first glance.

Unlike CD audio, which is simply a set of 1 to 99 identically-formatted
audio tracks (in terms of channel count, sample rate and bits per sample),
a DVD-Audio disc contains one or more titlesets.
Each titleset contains one or more titles, and each
title contains one or more tracks.
\begin{figure}[h]
  \includegraphics{figures/dvda/layout.pdf}
\end{figure}
\par
\noindent
Typically, a DVD-Audio disc will contain two titlesets,
one for audio and the other for video - which we can ignore.
The first titleset will often contain two titles,
one for 2 channel audio and the other for 5.1 channel audio.
Each title will usually contain a consistent number of tracks
as MLP or PCM encoded audio.
\par
With this in mind, we can now make some sense of
the \texttt{AUDIO\_TS} directory's contents:
\vskip .25in
$\texttt{\huge{AUDIO\_TS.IFO}}$
\hfill
information about the disc, including the number of titlesets
\vskip .25in
$\texttt{\huge{ATS\_}}\underbrace{\texttt{\huge{01}}}_{Titleset}\texttt{\huge{\_0.IFO}}$
\hfill
information about all the titles in a given titleset
\vskip .25in
$\texttt{\huge{ATS\_}}\underbrace{\texttt{\huge{01}}}_{Titleset}\texttt{\huge{\_}}\underbrace{\texttt{\huge{1}}}_{AOB~\#}\texttt{\huge{.AOB}}$
\hfill
audio data for one or more tracks in a given titleset
\vskip .25in
\par
All are binary files containing one or more, 2048 byte sectors.

\clearpage

\section{AUDIO\_TS.IFO}
Known as the ``Audio Manager'' or ``AMG'',
this is primarily a container of pointers to
other files on disc.
However, for our purposes, we're only interested
in the \VAR{Audio Titleset Count} value.
\begin{figure}[h]
  \includegraphics{figures/dvda/audio_ts_ifo.pdf}
\end{figure}

\clearpage

\section{ATS\_XX\_0.IFO}

\ALGORITHM{an \texttt{ATS\_XX\_0.IFO} file, a titleset number}{timestamps for each track in each title in the titleset, a list of sector pointers}
\SetKw{SEEK}{seek}
\SetKwData{IDENTIFIER}{identifier}
\SetKwData{TITLECOUNT}{title count}
\SetKwData{LASTADDRESS}{last byte address}
\SetKwData{TITLENUMBER}{title number}
\SetKwData{TITLEOFFSET}{title table offset}
\SetKwData{TRACKCOUNT}{track count}
\SetKwData{INDEXCOUNT}{index count}
\SetKwData{TITLELENGTH}{title PTS length}
\SetKwData{POINTERSOFFSET}{sector pointers offset}
\SetKwData{TRACKINDEX}{track index number}
\SetKwData{TRACKPTSINDEX}{track PTS index}
\SetKwData{TRACKPTSLENGTH}{track PTS length}
\SetKwData{INDEXID}{index ID}
\SetKwData{FIRSTSECTOR}{first sector}
\SetKwData{LASTSECTOR}{last sector}
$\IDENTIFIER \leftarrow$ \READ 12 bytes\;
\ASSERT $\IDENTIFIER = \texttt{"DVDAUDIO-ATS"}$\;
\SEEK to file position \texttt{0x800}\tcc*[r]{seek to the second sector in the file}
$\TITLECOUNT \leftarrow$ \READ 16 unsigned bits\;
\SKIP 16 bits\;
$\LASTADDRESS \leftarrow$ \READ 32 unsigned bits\;
\For{$i \leftarrow 0$ \emph{\KwTo}\TITLECOUNT}{
  $\text{\TITLENUMBER}_i \leftarrow$ \READ 8 unsigned bits\;
  \SKIP 24 bits\;
  $\text{\TITLEOFFSET}_i \leftarrow$ \READ 32 unsigned bits\;
}
\For(\tcc*[f]{read title information}){$i \leftarrow 0$ \emph{\KwTo}\TITLECOUNT}{
  \SEEK to file position $(\texttt{0x800} + \text{\TITLEOFFSET}_i)$\;
  \SKIP 16 bits\;
  $\text{\TRACKCOUNT}_i \leftarrow$ \READ 8 unsigned bits\;
  $\text{\INDEXCOUNT}_i \leftarrow$ \READ 8 unsigned bits\;
  $\text{\TITLELENGTH}_i \leftarrow$ \READ 32 unsigned bits\;
  \SKIP 32 bits\;
  $\text{\POINTERSOFFSET}_i \leftarrow$ \READ 16 unsigned bits\;
  \SKIP 16 bits\;
  \For(\tcc*[f]{read track information}){$j \leftarrow 0$ \emph{\KwTo}$\text{\TRACKCOUNT}_i$}{
    \SKIP 32 bits\;
    $\text{\TRACKINDEX}_{i~j} \leftarrow$ \READ 8 unsigned bits\;
    \SKIP 8 bits\;
    $\text{\TRACKPTSINDEX}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    $\text{\TRACKPTSLENGTH}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    \SKIP 48 bits\;
  }
  \SEEK to file position $(\texttt{0x800} + \text{\TITLEOFFSET}_i + \text{\POINTERSOFFSET}_i)$\;
  \For(\tcc*[f]{read index information}){$j \leftarrow 0$ \emph{\KwTo}$\text{\INDEXCOUNT}_i$}{
    $\text{\INDEXID}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    \ASSERT $\text{\INDEXID}_{i~j} = \texttt{0x01000000}$\;
    $\text{\FIRSTSECTOR}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
    $\text{\LASTSECTOR}_{i~j} \leftarrow$ \READ 32 unsigned bits\;
  }
}
\Return \TITLECOUNT, \TRACKCOUNT, \INDEXCOUNT, \TITLELENGTH, \TRACKINDEX,
\TRACKPTSINDEX, \TRACKPTSLENGTH, \FIRSTSECTOR, \LASTSECTOR\;
\EALGORITHM

\clearpage

\subsubsection{ATS\_XX\_0.IFO Second Sector}
\begin{figure}[h]
\includegraphics{figures/dvda/ats_xx_0.pdf}
\end{figure}

\subsubsection{Title Table}
\begin{figure}[h]
  \includegraphics{figures/dvda/ats_title.pdf}
\end{figure}

\subsubsection{Sector Pointers Table}
\begin{figure}[h]
  \includegraphics{figures/dvda/ats_sectors.pdf}
\end{figure}

\clearpage

\section{ATS\_XX\_X.AOB}

All of a titleset's AOB files can be considered part of a
single, contiguous collection of sectors, each 2048 bytes long.
Thus, it's possible for the start and end sectors for a given track
(as indicated in the sector pointers table) to span two or more
AOB files.
Each sector contains one or more packets as part of a
``Packetized Elementary Stream''.

\begin{figure}[h]
  \includegraphics{figures/dvda/ats_xx_x.pdf}
\end{figure}
\par
\noindent
Packets with a \VAR{stream ID} of \texttt{0xBD} contain encoded audio data.
\VAR{Packet data length} is the length of all data after
the \VAR{packet data length} field to the end of the packet.
\par
\noindent
Each sector within an AOB file is prefixed by a \VAR{Pack Header},
as follows:
\begin{figure}[h]
  \includegraphics{figures/dvda/aob_pack_header.pdf}
\end{figure}
\par
\noindent
The three \VAR{Current PTS} values (3 bits, 15 bits and 15 bits, respectively)
combine to indicate the current position within the stream, in PTS ticks.
There are 90,000 PTS ticks per second.

\clearpage

\subsection{Packet Payload Extraction}

\begin{figure}[h]
  \includegraphics{figures/dvda/audio_packet.pdf}
\end{figure}
\par
\noindent
MLP frame boundaries need not align with packet boundaries.
That is, a single MLP frame may span 2 or more AOB packets.

\clearpage

\section{MLP Decoding}
{\relsize{-1}
\ALGORITHM{packet data containing 1 or more MLP frames}{1 or more PCM frames}
\SetKwData{TOTALSIZE}{total frame size}
\While{MLP frames remain}{
  \SKIP 4 bits\;
  $\TOTALSIZE \leftarrow (\text{\READ 12 unsigned bits}) \times 2$\;
  \SKIP 16 bits\;
  \hyperref[mlp:framedecoding]{decode next $(\TOTALSIZE - 4)$ bytes as MLP frame}\;
}
\Return PCM frames\;
\EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_stream.pdf}
\end{figure}

\begin{landscape}

\subsection{MLP Frame Decoding}
\subsubsection{Persistent Variables}
{\relsize{-1}
\begin{tabular}{rrl}
\textbf{variable group} & \textbf{variable name} &
\textbf{used for} \\
\hline
\hline
\hyperref[mlp:readmajorsync]{\textbf{major sync}}
& $\textsf{substream count}$
& \hyperref[mlp:framedecoding]{frame decoding} \\
\hline
\hyperref[mlp:readrestartheader]{$\textbf{restart header}_s$}
& $\textsf{min channel}_s$
& read decoding parameters, reading residuals, channel filtering \\
& $\textsf{max channel}_s$
& read decoding parameters, reading residuals, channel filtering \\
& $\textsf{max matrix channel}_s$
& read decoding parameters, reading matrix params, channel rematrixing \\
& $\textsf{noise shift}_s$
& channel rematrixing \\
& $\textsf{noise gen seed}_s$
& channel rematrixing \\
& $\textsf{channel assignment}_{s~c}$
& channel reassignment \\
\hline
\hyperref[mlp:readdecodingparams]{$\textbf{decoding parameters}_s$}
& $\textsf{flag}_{s~i}$
& read decoding parameters \\
& $\textsf{block size}_s$
& reading residuals, channel filtering, channel rematrixing \\
& $\textsf{matrix count}_s$
& reading matrix params, reading residuals, channel rematrixing \\
& \hyperref[mlp:readmatrixparams]{$\textbf{matrix parameters}_{s~m}$} \\
& $\textsf{output shift}_{s~c}$
& output shifting \\
& $\textsf{quant step size}_{s~c}$
& reading residuals, channel filtering, channel rematrixing \\
& \hyperref[mlp:readchannelparams]{$\textbf{channel parameters}_{s~c}$} \\
\hline
\hyperref[mlp:readmatrixparams]{$\textbf{matrix parameters}_{s~m}$}
& $\textsf{out channel}_{s~m}$
& channel rematrixing \\
& $\textsf{LSB bypass}_{s~m}$
& reading residuals \\
& $\textsf{matrix coefficient}_{s~m~c}$
& channel rematrixing \\
& $\textsf{bypassed LSB}_{s~m~i}$
& channel rematrixing \\
\hline
\hyperref[mlp:readchannelparams]{$\textbf{channel parameters}_{s~c}$}
& \hyperref[mlp:readfirfilterparams]{$\textbf{FIR filter parameters}_{s~c}$} \\
& \hyperref[mlp:readiirfilterparams]{$\textbf{IIR filter parameters}_{s~c}$} \\
& $\textsf{Huffman offset}_{s~c}$
& reading residuals \\
& $\textsf{codebook}_{s~c}$
& reading residuals \\
& $\textsf{Huffman LSBs}_{s~c}$
& reading residuals \\
\hline
$\textbf{filter parameters}_{s~c}$
& $\textsf{order}_{s~c}$
& channel filtering \\
& $\textsf{shift}_{s~c}$
& channel filtering \\
& $\textsf{coefficient}_{s~c~i}$
& channel filtering \\
& $\textsf{state}_{s~c~i}$
& channel filtering \\
\end{tabular}
}


\end{landscape}

\subsubsection{Frame Decoding Process}
\label{mlp:framedecoding}
{\relsize{-1}
\ALGORITHM{MLP frame}{1 or more PCM frames}
\SetKw{OR}{or}
\SetKwData{BPS}{bits per sample}
\SetKwData{RATE}{sample rate}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{SUBSTREAMCOUNT}{substream count}
\SetKwData{CHECKDATA}{checkdata present}
\SetKwData{SUBSTREAMEND}{substream end}
\SetKwData{SUBSTREAM}{substream}
\SetKwData{PARITY}{parity}
\SetKwData{CRC}{CRC-8}
\SetKwData{RESTARTHEADER}{restart header}
\SetKwData{DECODINGPARAMS}{decoding parameters}
$\text{\SUBSTREAMCOUNT} \leftarrow$ \hyperref[mlp:readmajorsync]{read major sync}\;
\ASSERT $(\SUBSTREAMCOUNT = 1)$ \OR $(\SUBSTREAMCOUNT = 2)$\;
\For{$s \leftarrow 0$ \emph{\KwTo}\SUBSTREAMCOUNT}{
  $\left.\begin{tabular}{r}
    $\text{\CHECKDATA}_s$ \\
    $\text{\SUBSTREAMEND}_s$ \\
  \end{tabular}\right\rbrace \leftarrow$
  \hyperref[mlp:read_substream_info]{read substream info}\;
}
\eIf{$\text{\CHECKDATA}_0 = 1$}{
  $\text{\SUBSTREAM}_0 \leftarrow$ \hyperref[mlp:decode_substream]{decode next $(\text{\SUBSTREAMEND}_0 - 2)$ substream bytes}\;
  $\text{\PARITY}_0 \leftarrow$ \READ 8 unsigned bits\;
  $\text{\CRC}_0 \leftarrow$ \READ 8 unsigned bits\;
  \hyperref[mlp:verify_parity]{verify $\text{\PARITY}_0$, $\text{\CRC}_0$ of $\text{\SUBSTREAM}_0$}\;
}{
  $\text{\SUBSTREAM}_0 \leftarrow$ \hyperref[mlp:decode_substream]{decode next $\text{\SUBSTREAMEND}_0$ substream bytes}\;
}
\uIf{$\SUBSTREAMCOUNT = 1$}{
  \hyperref[mlp:rematrixing]{rematrix channels using $\text{\RESTARTHEADER}_0$ and $\text{\DECODINGPARAMS}_0$}\;
  \hyperref[mlp:output_shifts]{apply output shifts using $\text{\DECODINGPARAMS}_0$}\;
}
\ElseIf{$\SUBSTREAMCOUNT = 2$}{
  \eIf{$\text{\CHECKDATA}_1 = 1$}{
    $\text{\SUBSTREAM}_1 \leftarrow$ \hyperref[mlp:decode_substream]{decode next $(\text{\SUBSTREAMEND}_1 - \text{\SUBSTREAMEND}_0 - 2)$ substream bytes}\;
    $\text{\PARITY}_1 \leftarrow$ \READ 8 unsigned bits\;
    $\text{\CRC}_1 \leftarrow$ \READ 8 unsigned bits\;
    \hyperref[mlp:verify_parity]{verify $\text{\PARITY}_1$, $\text{\CRC}_1$ of $\text{\SUBSTREAM}_1$}\;
  }{
    $\text{\SUBSTREAM}_1 \leftarrow$
    \hyperref[mlp:decode_substream]{decode next $(\text{\SUBSTREAMEND}_1 - \text{\SUBSTREAMEND}_0)$ bytes}\;
  }
  \hyperref[mlp:rematrixing]{rematrix channels using $\text{\RESTARTHEADER}_1$ and $\text{\DECODINGPARAMS}_1$}\;
  \hyperref[mlp:output_shifts]{apply output shifts using $\text{\DECODINGPARAMS}_1$}\;
}
\Return substream channels as PCM frames\;
\EALGORITHM
}

\clearpage

\subsubsection{Reading Major Sync}
\label{mlp:readmajorsync}
This is a collection of information about the MLP stream
which occurs occasionally at the start of MLP frames.
Its values are consistent throughout the stream for any given track.
\par
\noindent
{\relsize{-1}
\ALGORITHM{MLP frame data}{substream count}
\SetKw{AND}{and}
\SetKw{OR}{or}
\SetKw{REWIND}{rewind stream}
\SetKwData{SYNCWORDS}{sync words}
\SetKwData{STREAMTYPE}{stream type}
\SetKwData{BPS}{bits per sample}
\SetKwFunction{BPSFUNC}{bps}
\SetKwData{RATE}{sample rate}
\SetKwFunction{RATEFUNC}{rate}
\SetKwData{CHANNELCOUNT}{channel count}
\SetKwData{CHANNELASSIGNMENT}{channel assignment}
\SetKwFunction{CHANNELFUNC}{channels}
\SetKwData{ISVBR}{is VBR}
\SetKwData{PEAKBITRATE}{peak bitrate}
\SetKwData{SUBSTREAMCOUNT}{substream count}
$\SYNCWORDS \leftarrow$ \READ 24 unsigned bits\;
$\STREAMTYPE \leftarrow$ \READ 8 unsigned bits\;
\eIf(\tcc*[f]{major sync found}){$(\SYNCWORDS = 16282223)$ \AND $(\STREAMTYPE = 187)$}{
  $\text{\BPS}_0 \leftarrow \BPSFUNC(\text{\READ 4 unsigned bits})$\;
  $\text{\BPS}_1 \leftarrow \BPSFUNC(\text{\READ 4 unsigned bits})$\;
  $\text{\RATE}_0 \leftarrow \RATEFUNC(\text{\READ 4 unsigned bits})$\;
  $\text{\RATE}_1 \leftarrow \RATEFUNC(\text{\READ 4 unsigned bits})$\;
  \SKIP 11 bits\;
  $(\text{\CHANNELCOUNT}~,~\text{\CHANNELASSIGNMENT}) \leftarrow \CHANNELFUNC(\text{\READ 5 unsigned bits})$\;
  \SKIP 48 bits\;
  $\text{\ISVBR} \leftarrow$ \READ 1 unsigned bit\;
  $\text{\PEAKBITRATE} \leftarrow$ \READ 15 unsigned bits\;
  $\text{\SUBSTREAMCOUNT} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $(\text{\SUBSTREAMCOUNT} = 1)$ \OR $(\text{\SUBSTREAMCOUNT} = 2)$\;
  \SKIP 92 bits\;
  \Return $\text{\SUBSTREAMCOUNT}$\;
}(\tcc*[f]{major sync not found}){
  \REWIND 32 bits\;
  \Return substream count from previous major sync\;
}
\EALGORITHM
}
\begin{small}
  \begin{tabular}{|c|r|r|r|l|}
    \hline
    value & \texttt{bps} & \texttt{rate} & channels & channel assignment \\
    \hline
    \texttt{00000} & 16 & 48000 & 1 & front center \\
    \texttt{00001} & 20 & 96000 & 2 & front left, front right\\
    \texttt{00010} & 24 & 192000 & 3 & front left, front right, back center \\
    \texttt{00011} & & & 4 & front left, front right, back left, back right\\
    \texttt{00100} & & & 3 & front left, front right, LFE \\
    \texttt{00101} & & & 4 & front left, front right, LFE, back center \\
    \texttt{00110} & & & 5 & front left, front right, LFE, back left, back right \\
    \texttt{00111} & & & 3 & front left, front right, front center \\
    \texttt{01000} & & 44100 & 4 & front left, front right, front center, back center \\
    \texttt{01001} & & 88200 & 5 & front left, front right, front center, back left, back right \\
    \texttt{01010} & & 176400 & 4 & front left, front right, front center, LFE\\
    \texttt{01011} & & & 5 & front left, front right, front center, LFE, back center \\
    \texttt{01100} & & & 6 & front left, front right, front center, LFE back left, back right \\
    \texttt{01101} & & & 4 & front left, front right, front center, back center \\
    \texttt{01110} & & & 5 & front left, front right, front center, back left, back right \\
    \texttt{01111} & & & 4 & front left, front right, front center, LFE \\
    \texttt{10000} & & & 5 & front left, front right, front center, LFE, back center \\
    \texttt{10001} & & & 6 & front left, front right, front center, LFE, back left, back right \\
    \texttt{10010} & & & 5 & front left, front right, back left, back right, LFE \\
    \texttt{10011} & & & 5 & front left, front right, back left, back right, front center \\
    \texttt{10100} & & & 6 & front left, front right, back left, back right, front center, LFE \\
    \hline
  \end{tabular}
\end{small}

\clearpage

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_major_sync.pdf}
\end{figure}
\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_major_sync_parse.pdf}
\end{figure}
{\relsize{-1}
\begin{tabular}{rl}
  $\text{group}_0$ bits-per-sample & 24 \\
  $\text{group}_1$ bits-per-sample & 24 \\
  $\text{group}_0$ sample rate & 96000 Hz \\
  $\text{group}_1$ sample rate & 96000 Hz \\
  channel count & 5 \\
  channel assignment & front left, front right, LFE, back left, back right \\
  is VBR & yes \\
  peak bitrate & 1600 \\
  substream count & 2 \\
\end{tabular}
}

\clearpage

\subsubsection{Substream Info}
\label{mlp:read_substream_info}
{\relsize{-1}
\ALGORITHM{MLP frame data}{checkdata present, substream end}
\SetKwData{EXTRAWORD}{extra word present}
\SetKwData{NONRESTART}{nonrestart substream}
\SetKwData{CHECKDATA}{checkdata present}
\SetKwData{SUBSTREAMEND}{substream end}
$\text{\EXTRAWORD} \leftarrow$ \READ 1 unsigned bit\;
\ASSERT $\text{\EXTRAWORD} = 0$\;
$\text{\NONRESTART} \leftarrow$ \READ 1 unsigned bit\;
$\text{\CHECKDATA} \leftarrow$ \READ 1 unsigned bit\;
\SKIP 1 bit\;
$\text{\SUBSTREAMEND} \leftarrow (\text{\READ 12 unsigned bits}) \times 2$\;
\Return $\left\lbrace\begin{tabular}{l}
\CHECKDATA \\
\SUBSTREAMEND \\
\end{tabular}\right.$\;
\EALGORITHM
}
\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_substream_info.pdf}
\end{figure}
\par
\noindent
For example, given a frame with 2 substreams
and 2 substream info fields:
\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_substream_info_parse.pdf}
\end{figure}
\begin{table}[h]
\begin{tabular}{rrr}
& $\text{substream}_0$ & $\text{substream}_1$ \\
\hline
extra word present & 0 & 0 \\
nonrestart substream & 0 & 0 \\
checkdata present & 1 & 1 \\
pad & 1 & 0 \\
substream end & $72 \times 2 = 148$ & $159 \times 2 = 318$ \\
\end{tabular}
\end{table}
\par
\noindent
$\text{Substream Data}_0$ contains
the next 148 bytes following the $\text{Substream Info}_1$ field,
and $\text{Substream Data}_1$ contains 170 bytes
following $\text{Substream Data}_0$.
In addition, \VAR{checkdata present} values of 1
means both substreams will be followed by 8 bit parity and CRC-8 values.

\clearpage

\subsection{Decoding Substream}
\label{mlp:decode_substream}
{\relsize{-1}
\ALGORITHM{1 or more blocks of MLP data}{1 or more channels of PCM data from multiple blocks}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{BLOCK}{block}
\SetKwData{OUTPUT}{output}
\SetKwData{LAST}{last block}
$\text{\OUTPUT}_s \leftarrow$ decode block to 1 or more channels of PCM data\;
$\text{\LAST} \leftarrow$ \READ 1 unsigned bit\;
\While{$\text{\LAST} = 0$}{
  $\text{\BLOCK}_s \leftarrow$ decode block to 1 or more channels of PCM data\;
  $\text{\OUTPUT}_{s} \leftarrow \text{\BLOCK}_{s}$ appended to $\text{\OUTPUT}_{s}$ on a channel-by-channel basis\;
  $\text{\LAST} \leftarrow$ \READ 1 unsigned bit\;
}
\BlankLine
\Return $\text{\OUTPUT}_s$\;
\EALGORITHM
}

\subsection{Decoding Block}
{\relsize{-1}
\ALGORITHM{MLP block data}{1 or more channels of PCM data}
\SetKwData{HEADERPRESENT}{restart header present}
\SetKwData{RESTARTHEADER}{restart header}
\SetKwData{DECODINGPARAMS}{decoding parameters}
\SetKwData{FILTERPARAMS}{filter parameters}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{BYPASSEDLSB}{bypassed LSB}
\SetKwData{RESIDUAL}{residual}
\SetKwData{FILTERED}{filtered}
\eIf(\tcc*[f]{decoding parameters present}){$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\HEADERPRESENT} \leftarrow$ \READ 1 unsigned bit\;
  \eIf{$\text{\HEADERPRESENT} = 1$}{
    $\text{\RESTARTHEADER}_s \leftarrow$ \hyperref[mlp:readrestartheader]{read restart header}\;
  }{
    $\text{\RESTARTHEADER}_s \leftarrow$ from previous block's restart header in substream\;
  }
  $\text{\DECODINGPARAMS}_s \leftarrow$ \hyperref[mlp:readdecodingparams]{read decoding parameters with $\text{\HEADERPRESENT}$}\;
}{
  $\text{\RESTARTHEADER}_s \leftarrow$ from previous block's restart header in substream\;
  $\text{\DECODINGPARAMS}_s \leftarrow$ from previous block's decoding parameters in substream\;
}
\BlankLine
$\left.\begin{tabular}{r}
  $\text{\BYPASSEDLSB}_s$ \\
  $\text{\RESIDUAL}_s$ \\
\end{tabular}\right\rbrace \leftarrow$
\hyperref[mlp:read_residuals]{read residual data based on $\text{\DECODINGPARAMS}_s$}\;
\BlankLine
\For{$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$\text{\MAXCHANNEL}_s$}{
  $\text{\FILTERED}_{s~c} \leftarrow$ \hyperref[mlp:channel_filtering]{filter $\text{\RESIDUAL}_s$ using $\text{\FILTERPARAMS}_{s~c}$}\;
}
\BlankLine
\Return $\text{\FILTERED}_{s}$\;
\EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_frame.pdf}
\end{figure}

\clearpage

\subsection{Reading Restart Header}
\label{mlp:readrestartheader}
{\relsize{-1}
\ALGORITHM{MLP substream data}{restart header parameters}
\SetKwData{HEADERSYNC}{header sync}
\SetKwData{NOISETYPE}{noise type}
\SetKwData{TIMESTAMP}{output timestamp}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{NOISESHIFT}{noise shift}
\SetKwData{NOISEGENSEED}{noise gen seed}
\SetKwData{CHECKDATAPRESENT}{check data present}
\SetKwData{LOSSLESSCHECK}{lossless check}
\SetKwData{CHANNELASSIGNMENT}{channel assignment}
\SetKwData{CHECKSUM}{checksum}
\SetKwData{RESTARTHEADER}{restart header}
$\text{\HEADERSYNC} \leftarrow$ \READ 13 unsigned bits\;
\ASSERT $\text{\HEADERSYNC} = \texttt{0x18F5}$\;
$\text{\NOISETYPE} \leftarrow$ \READ 1 unsigned bit\;
\ASSERT $\text{\NOISETYPE} = 0$\;
$\text{\TIMESTAMP} \leftarrow$ \READ 16 unsigned bits\;
$\text{\MINCHANNEL} \leftarrow$ \READ 4 unsigned bits\;
$\text{\MAXCHANNEL} \leftarrow$ \READ 4 unsigned bits\;
\ASSERT $\text{\MAXCHANNEL} \geq \text{\MINCHANNEL}$\;
$\text{\MAXMATRIXCHANNEL} \leftarrow$ \READ 4 unsigned bits\;
\ASSERT $\text{\MAXMATRIXCHANNEL} \geq \text{\MAXCHANNEL}$\;
$\text{\NOISESHIFT} \leftarrow$ \READ 4 unsigned bits\;
$\text{\NOISEGENSEED} \leftarrow$ \READ 23 unsigned bits\;
\SKIP 19 bits\;
$\text{\CHECKDATAPRESENT} \leftarrow$ \READ 1 unsigned bit\;
$\text{\LOSSLESSCHECK} \leftarrow$ \READ 8 unsigned bits\;
\SKIP 16 bits\;
\For{$c \leftarrow 0$ \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL} + 1)$}{
  $\text{\CHANNELASSIGNMENT}_{c} \leftarrow$ \READ 6 unsigned bits\;
  \ASSERT $\text{\CHANNELASSIGNMENT}_{c} \leq \text{\MAXMATRIXCHANNEL}$\;
}
$\text{\CHECKSUM} \leftarrow$ \READ 8 unsigned bits\;
\Return
$\RESTARTHEADER\left\lbrace\begin{tabular}{l}
  \MINCHANNEL \\
  \MAXCHANNEL \\
  \MAXMATRIXCHANNEL \\
  \NOISESHIFT \\
  \NOISEGENSEED \\
  \CHANNELASSIGNMENT
\end{tabular}\right.$\;
\EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_restart_header.pdf}
\end{figure}

\clearpage

\subsubsection{Reading Restart Header Example}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_restart_header_parse1.pdf}
\end{figure}
\begin{table}[h]
{\relsize{-1}
  \begin{tabular}{rl}
    header sync & \texttt{0x18F5} \\
    noise type & 0 \\
    output timestamp & 0 \\
    min channel & 0 \\
    max channel & 1 \\
    max matrix channel & 1 \\
    noise shift & 0 \\
    noise gen seed & 1 \\
    check data present & 0 \\
    lossless check & 0 \\
    $\text{channel assignment}_0$ & 0 \\
    $\text{channel assignment}_1$ & 1 \\
    checksum & \texttt{0x11} \\
  \end{tabular}
}
\end{table}

\clearpage

\subsection{Reading Decoding Parameters}
\label{mlp:readdecodingparams}
{\relsize{-1}
\ALGORITHM{MLP substream data, restart header present flag, restart header parameters}{decoding parameters}
\SetKw{OR}{or}
\SetKw{AND}{and}
\SetKwData{HEADERPRESENT}{restart header present}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{PARAMSPRESENT}{parameters present}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{MATRIXPARAMS}{matrix parameters}
\SetKwData{MATRIXCOUNT}{matrix count}
\SetKwData{OUTPUTSHIFT}{output shift}
\SetKwData{QUANTSTEP}{quant step size}
\SetKwData{FLAG}{flag}
\uIf(\tcc*[f]{parameter presence flags}){$\text{\HEADERPRESENT}_s = 1$}{
  \uIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
    \For{$f \leftarrow 0$ \emph{\KwTo}8}{
      $\text{\FLAG}_{s~f} \leftarrow$ \READ 1 unsigned bit\;
    }
  }
  \lElse{
    $\text{\FLAG}_s \leftarrow \texttt{[1, 1, 1, 1, 1, 1, 1, 1]}$\;
  }
}
\uElseIf{$(\text{\FLAG}_{s~0} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  \For{$f \leftarrow 0$ \emph{\KwTo}8}{
    $\text{\FLAG}_{s~f} \leftarrow$ \READ 1 unsigned bit\;
  }
}
\Else{
  $\text{\FLAG}_s \leftarrow$ from previous block in substream\;
}
\uIf(\tcc*[f]{block size}){$(\text{\FLAG}_{s~7} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\BLOCKSIZE}_s \leftarrow$ \READ 9 unsigned bits\;
  \ASSERT $\text{\BLOCKSIZE}_s \geq 8$\;
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $\text{\BLOCKSIZE}_s \leftarrow 8$\;
}
\Else{
  $\text{\BLOCKSIZE}_s \leftarrow$ from previous block in substream\;
}
\uIf(\tcc*[f]{matrix parameters}){$(\text{\FLAG}_{s~6} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\MATRIXCOUNT}_{s} \leftarrow$ \READ 4 unsigned bits\;
  \For{$m \leftarrow 0$ \emph{\KwTo}$\text{\MATRIXCOUNT}_{s}$}{
    $\text{\MATRIXPARAMS}_{s~c} \leftarrow$ \hyperref[mlp:readmatrixparams]{read matrix parameters}\;
  }
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $\text{\MATRIXCOUNT}_{s} \leftarrow 0$\;
}
\Else{
  $\text{\MATRIXCOUNT}_{s} \leftarrow$ from previous block in substream\;
  $\text{\MATRIXPARAMS}_{s} \leftarrow$ from previous block in substream\;
}
\uIf(\tcc*[f]{output shifts}){$(\text{\FLAG}_{s~5} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  \For{$c \leftarrow 0$ \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL}_s + 1)$}{
    $\text{\OUTPUTSHIFT}_{s~c} \leftarrow$ \READ 4 signed bits\;
  }
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  \For{$c \leftarrow 0$ \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL}_s + 1)$}{
    $\text{\OUTPUTSHIFT}_{s~c} \leftarrow 0$\;
  }
}
\Else{
  $\text{\OUTPUTSHIFT}_{s} \leftarrow$ from previous block in substream\;
}
\uIf(\tcc*[f]{quant step sizes}){$(\text{\FLAG}_{s~4} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  \For{$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
    $\text{\QUANTSTEP}_{s~c} \leftarrow$ \READ 4 unsigned bits\;
  }
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  \For{$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
    $\text{\QUANTSTEP}_{s~c} \leftarrow 0$\;
  }
}
\Else{
  $\text{\QUANTSTEP}_s \leftarrow$ from previous block in substream\;
}
\EALGORITHM
}

\clearpage

{\relsize{-1}
  \begin{algorithm}[H]
    \DontPrintSemicolon
    \SetKw{AND}{and}
    \SetKw{READ}{read}
    \SetKw{ASSERT}{assert}
    \SetKwData{BLOCKSIZE}{block size}
    \SetKwData{HEADERPRESENT}{restart header present}
    \SetKwData{MINCHANNEL}{min channel}
    \SetKwData{MAXCHANNEL}{max channel}
    \SetKwData{MATRIXCOUNT}{matrix count}
    \SetKwData{MATRIX}{matrix parameters}
    \SetKwData{MATRIXOUTCH}{matrix out channel}
    \SetKwData{LSBBYPASS}{LSB bypass}
    \SetKwData{MATRIXCOEFF}{matrix coeff}
    \SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
    \SetKwData{OUTPUTSHIFT}{output shift}
    \SetKwData{QUANTSTEP}{quant step size}
    \SetKwData{CHANNELPARAMS}{channel parameters}
    \SetKwData{FLAG}{flag}
    \SetKwData{FIRPARAMS}{FIR filter parameters}
    \SetKwData{FIRORDER}{FIR order}
    \SetKwData{FIRSHIFT}{FIR shift}
    \SetKwData{FIRCOEFF}{FIR coeff}
    \SetKwData{FIRSTATE}{FIR state}
    \SetKwData{IIRPARAMS}{IIR filter parameters}
    \SetKwData{IIRORDER}{IIR order}
    \SetKwData{IIRSHIFT}{IIR shift}
    \SetKwData{IIRCOEFF}{IIR coeff}
    \SetKwData{IIRSTATE}{IIR state}
    \SetKwData{CODEBOOK}{codebook}
    \SetKwData{HUFFMANOFFSET}{Huffman offset}
    \SetKwData{HUFFMANLSBS}{Huffman LSBs}
    \SetKwData{DECODINGPARAMETERS}{decoding parameters}
    \SetKwFunction{LEN}{len}
    \For(\tcc*[f]{channel parameters}){$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
      \uIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
        $\text{\CHANNELPARAMS}_{s~c} \leftarrow $ \hyperref[mlp:readchannelparams]{read channel parameters}\;
      }
      \uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
        $\text{\CHANNELPARAMS}_{s~c} \leftarrow \left\lbrace\begin{tabular}{ll}
        $\text{\FIRPARAMS}_{s~c} $ & $ \leftarrow \left\lbrace\begin{tabular}{ll}
        $\text{\FIRORDER}_{s~c}$ & $\leftarrow 0$ \\
        $\text{\FIRSHIFT}_{s~c}$ & $\leftarrow 0$ \\
        $\text{\FIRCOEFF}_{s~c}$ & $\leftarrow \texttt{[]}$ \\
\end{tabular}\right.$ \\
        $\text{\IIRPARAMS}_{s~c} $ & $ \leftarrow \left\lbrace\begin{tabular}{ll}
        $\text{\IIRORDER}_{s~c}$ & $\leftarrow 0$ \\
        $\text{\IIRSHIFT}_{s~c}$ & $\leftarrow 0$ \\
        $\text{\IIRCOEFF}_{s~c}$ & $\leftarrow \texttt{[]}$ \\
        $\text{\IIRSTATE}_{s~c}$ & $\leftarrow \texttt{[]}$ \\
\end{tabular}\right.$ \\
        $\text{\HUFFMANOFFSET}_{s~c} $ & $ \leftarrow 0$ \\
        $\text{\CODEBOOK}_{s~c} $ & $ \leftarrow 0$ \\
        $\text{\HUFFMANLSBS}_{s~c} $ & $ \leftarrow 23$ \\
\end{tabular}\right.$\;
      }
      \Else{
        $\text{\CHANNELPARAMS}_{s~c} \leftarrow $ from previous block's corresponding channel in substream\;
      }
    }
    \Return $\text{\DECODINGPARAMETERS}_s\left\lbrace\begin{tabular}{l}
    $\text{\FLAG}_s$ \\
    $\text{\BLOCKSIZE}_s$ \\
    $\text{\MATRIXCOUNT}_s$ \\
    $\text{\MATRIX}_s$ \\
    $\text{\OUTPUTSHIFT}_s$ \\
    $\text{\QUANTSTEP}_s$ \\
    $\text{\CHANNELPARAMS}_s$ \\
    \end{tabular}\right.$\;
  \end{algorithm}
}

\begin{figure}[h]
  \centering
  \includegraphics[height=3.5in,keepaspectratio]{figures/dvda/mlp_decoding_params.pdf}
\end{figure}


\clearpage

\subsubsection{Reading Matrix Parameters}
\label{mlp:readmatrixparams}
{\relsize{-1}
  \ALGORITHM{MLP substream data, max matrix channel}{matrix parameters}
  \SetKwData{MATRIXPARAMETERS}{matrix parameters}
  \SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
  \SetKwData{MATRIXOUTCH}{out channel}
  \SetKwData{FRACTIONALBITS}{fractional bits}
  \SetKwData{LSBBYPASS}{LSB bypass}
  \SetKwData{BYPASSEDLSB}{bypassed LSB}
  \SetKwData{MATRIXCOEFF}{matrix coefficient}
  $\text{\MATRIXOUTCH}_{s~m} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $\text{\MATRIXOUTCH}_{s~m} \leq \text{\MAXMATRIXCHANNEL}_s$\;
  $\text{\FRACTIONALBITS} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $\text{\FRACTIONALBITS} \leq 14$\;
  $\text{\LSBBYPASS}_{s~m} \leftarrow$ \READ 1 unsigned bit\;
  \For{$c \leftarrow 0$ \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL}_s + 3)$}{
    \eIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
      $v_{c} \leftarrow $ \READ $(\text{\FRACTIONALBITS} + 2)$ signed bits\;
      $\text{\MATRIXCOEFF}_{s~m~c} \leftarrow v_{c} \times 2 ^ {14 - \text{\FRACTIONALBITS}}$\;
    }{
      $\text{\MATRIXCOEFF}_{s~m~c} \leftarrow 0$\;
    }
  }
  $\text{\BYPASSEDLSB}_{s~m} \leftarrow \texttt{[]}$\tcc*[r]{populated by residual block}
  \BlankLine
  \Return $\text{\MATRIXPARAMETERS}_{s~m}\left\lbrace\begin{tabular}{l}
  $\text{\MATRIXOUTCH}_{s~m}$ \\
  $\text{\LSBBYPASS}_{s~m}$ \\
  $\text{\MATRIXCOEFF}_{s~m}$ \\
  $\text{\BYPASSEDLSB}_{s~m}$ \\
  \end{tabular}\right.$\;
  \EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_matrix_params.pdf}
\end{figure}

\clearpage

\subsubsection{Reading Channel Parameters}
\label{mlp:readchannelparams}
{\relsize{-1}
\ALGORITHM{MLP substream data, restart header present, decoding parameter flags}{channel parameters}
\SetKw{AND}{and}
\SetKwData{CHANNELPARAMS}{channel parameters}
\SetKwData{HEADERPRESENT}{restart header present}
\SetKwData{FLAG}{flag}
\SetKwData{FIRPARAMS}{FIR filter parameters}
\SetKwData{FIRORDER}{FIR order}
\SetKwData{FIRSHIFT}{FIR shift}
\SetKwData{FIRCOEFF}{FIR coeff}
\SetKwData{IIRPARAMS}{IIR filter parameters}
\SetKwData{IIRORDER}{IIR order}
\SetKwData{IIRSHIFT}{IIR shift}
\SetKwData{IIRCOEFF}{IIR coeff}
\SetKwData{IIRSTATE}{IIR state}
\SetKwData{CODEBOOK}{codebook}
\SetKwData{HUFFMANOFFSET}{Huffman offset}
\SetKwData{HUFFMANLSBS}{Huffman LSBs}
\uIf(\tcc*[f]{FIR filter parameters}){$(\text{\FLAG}_{s~3} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\FIRPARAMS}_{s~c} \leftarrow $ \hyperref[mlp:readfirfilterparams]{read FIR filter parameters}\;
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $\text{\FIRPARAMS}_{s~c} \leftarrow \left\lbrace\begin{tabular}{l}
  $\text{\FIRORDER}_{s~c} \leftarrow 0$ \\
  $\text{\FIRSHIFT}_{s~c} \leftarrow 0$\\
  $\text{\FIRCOEFF}_{s~c} \leftarrow \texttt{[]}$
  \end{tabular}\right.
  $\;
}
\Else{
  $\text{\FIRPARAMS}_{s~c} \leftarrow$ from previous block's corresponding channel in substream\;
}
\BlankLine
\uIf(\tcc*[f]{IIR filter parameters}){$(\text{\FLAG}_{s~2} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\IIRPARAMS}_{s~c} \leftarrow$ \hyperref[mlp:readiirfilterparams]{read IIR filter parameters}\;
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $\text{\IIRPARAMS}_{s~c} \leftarrow \left\lbrace\begin{tabular}{l}
  $\text{\IIRORDER}_{s~c} \leftarrow 0$ \\
  $\text{\IIRSHIFT}_{s~c} \leftarrow 0$\\
  $\text{\IIRCOEFF}_{s~c} \leftarrow \texttt{[]}$ \\
  $\text{\IIRSTATE}_{s~c} \leftarrow \texttt{[]}$
  \end{tabular}\right.
  $\;
}
\Else{
  $\text{\IIRPARAMS}_{s~c} \leftarrow$ from previous block's corresponding channel in substream\;
}
\BlankLine
\uIf(\tcc*[f]{Huffman offset}){$(\text{\FLAG}_{s~1} = 1)$ \AND $((\READ~\textnormal{1 unsigned bit}) = 1)$}{
  $\text{\HUFFMANOFFSET}_{s~c} \leftarrow$ \READ 15 signed bits\;
}
\uElseIf{$\text{\HEADERPRESENT}_s = 1$}{
  $\text{\HUFFMANOFFSET}_{s~c} \leftarrow 0$\;
}
\Else{
  $\text{\HUFFMANOFFSET}_{s~c} \leftarrow$ from previous block's corresponding channel in substream\;
}
$\text{\CODEBOOK}_{s~c} \leftarrow$ \READ 2 unsigned bits\;
$\text{\HUFFMANLSBS}_{s~c} \leftarrow$ \READ 5 unsigned bits\;
\ASSERT $\text{\HUFFMANLSBS}_{s~c} \leq 24$\;
\Return $\text{\CHANNELPARAMS}_{s~m}\left\lbrace\begin{tabular}{l}
$\text{\FIRPARAMS}_{s~m}$ \\
$\text{\IIRPARAMS}_{s~m}$ \\
$\text{\HUFFMANOFFSET}_{s~m}$ \\
$\text{\CODEBOOK}_{s~m}$ \\
$\text{\HUFFMANLSBS}_{s~m}$ \\
\end{tabular}\right.$\;
\EALGORITHM
}

\begin{figure}[h]
  \centering
  \includegraphics[height=1.75in,keepaspectratio]{figures/dvda/mlp_channel_params.pdf}
\end{figure}

\clearpage

\subsubsection{Reading FIR Filter Parameters}
\label{mlp:readfirfilterparams}
{\relsize{-1}
  \ALGORITHM{MLP substream data}{FIR filter parameters}
  \SetKwData{ORDER}{order}
  \SetKwData{SHIFT}{shift}
  \SetKwData{COEFFBITS}{coeff bits}
  \SetKwData{COEFFSHIFT}{coeff shift}
  \SetKwData{COEFF}{coefficient}
  \SetKwData{STATEBITS}{state bits}
  \SetKwData{STATESHIFT}{state shift}
  \SetKwData{FIRPARAMS}{FIR filter parameters}
  $\text{\ORDER}_{s~c} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $\text{\ORDER}_{s~c} \leq 8$\;
  \eIf{$\text{\ORDER}_{s~c} > 0$}{
    $\text{\SHIFT}_{s~c} \leftarrow$ \READ 4 unsigned bits\;
    $\text{\COEFFBITS} \leftarrow$ \READ 5 unsigned bits\;
    \ASSERT $1 < \text{\COEFFBITS} < 16$\;
    $\text{\COEFFSHIFT} \leftarrow$ \READ 3 unsigned bits\;
    \ASSERT $(\text{\COEFFBITS} + \text{\COEFFSHIFT}) \leq 16$\;
    \For{$i \leftarrow 0$ \emph{\KwTo}$\text{\ORDER}_{s~c}$}{
      $v_{i} \leftarrow$ \READ $(\text{\COEFFBITS})$ signed bits\;
      $\text{\COEFF}_{s~c~i} \leftarrow v_{i} \times 2 ^ {\text{\COEFFSHIFT}}$\;
    }
    \ASSERT $(\READ~\textnormal{1 unsigned bit}) = 0$\;
  }{
    $\text{\SHIFT}_{s~c} \leftarrow 0$\;
    $\text{\COEFF}_{s~c} \leftarrow \texttt{[]}$\;
  }
  \Return
  $\text{\FIRPARAMS}_{s~c}\left\lbrace\begin{tabular}{l}
  $\text{\ORDER}_{s~c}$ \\
  $\text{\SHIFT}_{s~c}$ \\
  $\text{\COEFF}_{s~c}$
  \end{tabular}\right.$\;
  \EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_fir_filter_params.pdf}
\end{figure}

\clearpage

\subsubsection{Reading IIR Filter Parameters}
\label{mlp:readiirfilterparams}
{\relsize{-1}
  \ALGORITHM{MLP substream data}{IIR filter parameters}
  \SetKw{KwDownTo}{downto}
  \SetKwData{ORDER}{order}
  \SetKwData{SHIFT}{shift}
  \SetKwData{COEFFBITS}{coeff bits}
  \SetKwData{COEFFSHIFT}{coeff shift}
  \SetKwData{COEFF}{coefficient}
  \SetKwData{STATEBITS}{state bits}
  \SetKwData{STATESHIFT}{state shift}
  \SetKwData{STATE}{state}
  \SetKwData{IIRPARAMS}{IIR filter params}
  $\text{\ORDER}_{s~c} \leftarrow$ \READ 4 unsigned bits\;
  \ASSERT $\text{\ORDER}_{s~c} \leq 8$\;
  \eIf{$\text{\ORDER}_{s~c} > 0$}{
    $\text{\SHIFT}_{s~c} \leftarrow$ \READ 4 unsigned bits\;
    $\text{\COEFFBITS} \leftarrow$ \READ 5 unsigned bits\;
    \ASSERT $1 < \text{\COEFFBITS} < 16$\;
    $\text{\COEFFSHIFT} \leftarrow$ \READ 3 unsigned bits\;
    \ASSERT $(\text{\COEFFBITS} + \text{\COEFFSHIFT}) \leq 16$\;
    \For{$i \leftarrow 0$ \emph{\KwTo}$\text{\ORDER}_{s~c}$}{
      $v_{i} \leftarrow$ \READ $(\text{\COEFFBITS})$ signed bits\;
      $\text{\COEFF}_{s~c~i} \leftarrow v_{i} \times 2 ^ {\text{\COEFFSHIFT}}$\;
    }
    \eIf{$((\READ~\textnormal{1 unsigned bit}) = 1)$}{
      $\text{\STATEBITS} \leftarrow$ \READ 4 unsigned bits\;
      $\text{\STATESHIFT} \leftarrow$ \READ 4 unsigned bits\;
      \For(\tcc*[f]{read state values in reverse order}){$i \leftarrow \text{\ORDER}_{s~c}$ \emph{\KwDownTo}0}{
        $s_{i} \leftarrow$ \READ $(\text{\STATEBITS})$ signed bits\;
        $\text{\STATE}_{s~c~i} \leftarrow s_{i} \times 2 ^ {\text{\STATESHIFT}}$\;
      }
    }{
      $\text{\STATE}_{s~c} \leftarrow \texttt{[]}$\;
    }
  }{
    $\text{\SHIFT}_{s~c} \leftarrow 0$\;
    $\text{\COEFF}_{s~c} \leftarrow \texttt{[]}$\;
    $\text{\STATE}_{s~c} \leftarrow \texttt{[]}$\;
  }
  \Return
  $\text{\IIRPARAMS}_{s~c}\left\lbrace\begin{tabular}{l}
  $\text{\ORDER}_{s~c}$ \\
  $\text{\SHIFT}_{s~c}$ \\
  $\text{\COEFF}_{s~c}$ \\
  $\text{\STATE}_{s~c}$
  \end{tabular}\right.$\;
  \EALGORITHM
}

\begin{figure}[h]
  \centering
  \includegraphics[height=2.5in,keepaspectratio]{figures/dvda/mlp_iir_filter_params.pdf}
\end{figure}

\clearpage

\subsubsection{Reading Decoding Parameters Example}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_decoding_params_parse.pdf}
\end{figure}

\clearpage

For example, given that a restart header is present with the values:
\begin{table}[h]
  {\relsize{-1}
    \begin{tabular}{rl}
      min channel & 0 \\
      max channel & 1 \\
      max matrix channel & 1 \\
    \end{tabular}
  }
\end{table}
\par
\noindent
our decoding parameters for a given substream are:
\begin{table}[h]
{\relsize{-1}
  \begin{tabular}{rlrl}
    \hline
    \textsf{flags present} & 0 \\
    \textsf{flags} & \texttt{[1, 1, 1, 1, 1, 1, 1, 1]} \\
    \hline
    \textsf{block size present} & 0 \\
    \textsf{block size} & 8 PCM frames \\
    \hline
    \textsf{matrix parameters present} & 1 \\
    \textsf{matrix count} & 2 \\
    $\textsf{matrix out channel}_0$ & 1 &
    $\textsf{matrix out channel}_1$ & 0 \\
    $\textsf{fractional bits}_0$ & 13 &
    $\textsf{fractional bits}_1$ & 13 \\
    $\textsf{LSB bypass}_0$ & 0 &
    $\textsf{LSB bypass}_1$ & 0 \\
    $\textsf{matrix coeff. present}_{0~0}$ & 0 &
    $\textsf{matrix coeff. present}_{1~0}$ & 1 \\
    $\textsf{matrix coeff.}_{0~0}$ & 0 &
    $\textsf{matrix coeff.}_{1~0}$ & -2053 \\
    $\textsf{matrix coeff. present}_{0~1}$ & 1 &
    $\textsf{matrix coeff. present}_{1~1}$ & 0 \\
    $\textsf{matrix coeff.}_{0~1}$ & -2053 &
    $\textsf{matrix coeff.}_{1~1}$ & 0 \\
    $\textsf{matrix coeff. present}_{0~2}$ & 1 &
    $\textsf{matrix coeff. present}_{1~2}$ & 1 \\
    $\textsf{matrix coeff.}_{0~2}$ & -32 &
    $\textsf{matrix coeff.}_{1~2}$ & 32 \\
    $\textsf{matrix coeff. present}_{0~3}$ & 1 &
    $\textsf{matrix coeff. present}_{1~3}$ & 1 \\
    $\textsf{matrix coeff.}_{0~3}$ & 32 &
    $\textsf{matrix coeff.}_{1~3}$ & 32 \\
    \hline
    \textsf{output shift present} & 1 \\
    $\textsf{output shift}_0$ & 1 &
    $\textsf{output shift}_1$ & 1 \\
    \hline
    \textsf{quantum step size present} & 0 \\
    \hline
    $\textsf{channel parameters present}_0$ & 1 &
    $\textsf{channel parameters present}_1$ & 1 \\
    $\textsf{FIR parameters present}_0$ & 0 &
    $\textsf{FIR parameters present}_1$ & 0 \\
    $\textsf{IIR parameters present}_0$ & 0 &
    $\textsf{IIR parameters present}_1$ & 0 \\
    $\textsf{Huffman offset present}_0$ & 0 &
    $\textsf{Huffman offset present}_1$ & 0 \\
    $\textsf{codebook}_0$ & 0 &
    $\textsf{codebook}_1$ & 0 \\
    $\textsf{Huffman LSB}_0$ & 1 &
    $\textsf{Huffman LSB}_1$ & 1 \\
    \hline
  \end{tabular}
}
\end{table}

\clearpage

\subsection{Reading Residual Data}
\label{mlp:read_residuals}
{\relsize{-1}
\ALGORITHM{block size, min channel, max channel, matrix count; LSB bypass for each matrix;\newline quant step size, Huffman LSB, codebook, Huffman offset for each channel}{bypassed LSBs for each matrix, residuals for each channel}
\SetKwData{MINCHANNEL}{min channel}
\SetKwData{MAXCHANNEL}{max channel}
\SetKwData{CODEBOOK}{codebook}
\SetKwData{LSBBITS}{LSB bits}
\SetKwData{HUFFMANLSBS}{Huffman LSBs}
\SetKwData{QUANTSTEP}{quant step size}
\SetKwData{SIGNSHIFT}{sign shift}
\SetKwData{HUFFMANOFFSET}{Huffman offset}
\SetKwData{SIGNEDHUFFMANOFFSET}{signed Huffman offset}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{MATRIXCOUNT}{matrix count}
\SetKwData{LSBBYPASS}{LSB bypass}
\SetKwData{BYPASSEDLSB}{bypassed LSB}
\SetKwData{MSB}{MSB}
\SetKwData{LSB}{LSB}
\SetKwData{RESIDUAL}{residual}
\For(\tcc*[f]{calculate signed Huffman offset}){$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
  $\text{\LSBBITS}_{s~c} \leftarrow \text{\HUFFMANLSBS}_{s~c} - \text{\QUANTSTEP}_{s~c}$\;
  \eIf{$\text{\CODEBOOK}_{s~c} > 0$}{
    $\text{\SIGNSHIFT}_{s~c} \leftarrow \text{\LSBBITS}_{s~c} + 2 - \text{\CODEBOOK}_{s~c}$\;
    \eIf{$\text{\SIGNSHIFT}_{s~c} \geq 0$}{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c} - 7 \times 2 ^ {\text{\LSBBITS}_{s~c}} - 2 ^ {\text{\SIGNSHIFT}_{s~c}}$\;
    }{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c} - 7 \times 2 ^ {\text{\LSBBITS}_{s~c}}$\;
    }
  }{
    $\text{\SIGNSHIFT}_{s~c} \leftarrow \text{\LSBBITS}_{s~c} - 1$\;
    \eIf{$\text{\SIGNSHIFT}_{s~c} \geq 0$}{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c} - 2 ^ {\text{\SIGNSHIFT}_{s~c}}$\;
    }{
      $\text{\SIGNEDHUFFMANOFFSET}_{s~c} \leftarrow \text{\HUFFMANOFFSET}_{s~c}$\;
    }
  }
}
\BlankLine
\For{$i \leftarrow 0$ \emph{\KwTo}$\text{\BLOCKSIZE}_s$}{
  \For(\tcc*[f]{read bypassed LSBs for each matrix}){$m \leftarrow 0$ \emph{\KwTo}$\text{\MATRIXCOUNT}_s$}{
    \eIf{$\text{\LSBBYPASS}_{s~m} = 1$}{
      $\text{\BYPASSEDLSB}_{s~m~i} \leftarrow$ \READ 1 unsigned bit\;
    }{
      $\text{\BYPASSEDLSB}_{s~m~i} \leftarrow 0$\;
    }
  }
  \For(\tcc*[f]{read residuals for each channel}){$c \leftarrow \text{\MINCHANNEL}_s$ \emph{\KwTo}$(\text{\MAXCHANNEL}_s + 1)$}{
    \uIf{$\text{\CODEBOOK}_{s~c} = 0$}{
      $\text{\MSB}_{s~c~i} \leftarrow 0$\;
    }
    \uElseIf{$1 \leq \text{\CODEBOOK}_{s~c} \leq 3$}{
      $\text{\MSB}_{s~c~i} \leftarrow$ read Huffman value from $\text{\CODEBOOK}_{s~c}$\;
    }
    \Else{$\text{\MSB}_{s~c~i} \leftarrow -1$}
    \ASSERT $\text{\MSB}_{s~c~i} \geq 0$\;
    \BlankLine
    $\text{\LSB}_{s~c~i} \leftarrow$ \READ $(\text{\LSBBITS}_{s~c})$ unsigned bits\;
    $\text{\RESIDUAL}_{s~c~i} \leftarrow ((\text{\MSB}_{s~c~i} \times 2 ^ {\text{\LSBBITS}_{s~c}}) + \text{\LSB}_{s~c~i} + \text{\SIGNEDHUFFMANOFFSET}_{s~c}) \times 2 ^ {\text{\QUANTSTEP}_{s~c}}$\;
  }
}
\BlankLine
\Return $\left\lbrace\begin{tabular}{l}
$\text{\BYPASSEDLSB}_s$ \\
$\text{\RESIDUAL}_s$ \\
\end{tabular}\right.$\;
\EALGORITHM
}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_residuals.pdf}
\end{figure}

\clearpage

\begin{figure}[h]
  \label{mlp_codebooks}
  \includegraphics{figures/dvda/mlp_codebook1.pdf}
  \caption{Codebook 1}
  \vskip 2em
  \includegraphics{figures/dvda/mlp_codebook2.pdf}
  \caption{Codebook 2}
  \vskip 2em
  \includegraphics{figures/dvda/mlp_codebook3.pdf}
  \caption{Codebook 3}
\end{figure}

\clearpage

\subsubsection{Reading Residuals Example}
Given the channel parameters:
\begin{table}[h]
{\relsize{-1}
\begin{tabular}{rrr}
& channel 0 & channel 1 \\
\hline
$\textsf{Huffman offset}_c$ & 0 & 0 \\
$\textsf{codebook}_c$ & 1 & 2 \\
$\textsf{Huffman LSBs}_c$ & 2 & 2 \\
\hline
$\textsf{LSB bits}_c$ & 2 & 2 \\
$\textsf{sign shift}_c$ & $3$ & $2$ \\
$\textsf{signed Huffman offset}_c$ & $0 - 7 \times 2 ^ 2 - 2 ^ 3 = -36$ & $0 - 7 \times 2 ^ 2 - 2 ^ 2 = -32$ \\
\end{tabular}
}
\end{table}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_block_parse.pdf}
\end{figure}
{\relsize{-1}
  \begin{tabular}{r||rr>{$}r<{$}|rr>{$}r<{$}}
    $i$ & $\text{MSB}_{0~i}$ & $\text{LSB}_{0~i}$ & \text{residual}_{0~i} &
    $\text{MSB}_{1~i}$ & $\text{LSB}_{1~i}$ & \text{residual}_{1~i} \\
    \hline
    0 & 9 & 3 & 9 \times 2 ^ 2 + 3 - 36 = 3 &
    7 & 1 & 7 \times 2 ^ 2 + 1 - 32 = -3 \\
    1 & 11 & 2 & 11 \times 2 ^ 2 + 2 - 36 = 10 &
    7 & 2 & 7 \times 2 ^ 2 + 2 - 32 = -2 \\
    2 & 11 & 0 & 11 \times 2 ^ 2 + 0 - 36 = 8 &
    8 & 0 & 8 \times 2 ^ 2 + 0 - 32 = 0 \\
    3 & 8 & 3 & 8 \times 2 ^ 2 + 3 - 36 = -1 &
    9 & 3 & 9 \times 2 ^ 2 + 3 - 32 = 7 \\
    4 & 8 & 3 & 8 \times 2 ^ 2 + 3 - 36 = -1 &
    3 & 3 & 3 \times 2 ^ 2 + 3 - 32 = -17 \\
    5 & 11 & 0 & 11 \times 2 ^ 2 + 0 - 36 = 8 &
    4 & 1 & 4 \times 2 ^ 2 + 1 - 32 = -15 \\
    6 & 12 & 3 & 12 \times 2 ^ 2 + 3 - 36 = 15 &
    6 & 0 & 6 \times 2 ^ 2 + 0 - 32 = -8 \\
    7 & 11 & 1 & 11 \times 2 ^ 2 + 1 - 36 = 9 &
    6 & 3 & 6 \times 2 ^ 2 + 3 - 32 = -5 \\
    8 & 5 & 0 & 5 \times 2 ^ 2 + 0 - 36 = -16 &
    8 & 0 & 8 \times 2 ^ 2 + 0 - 32 = 0 \\
    9 & 7 & 0 & 7 \times 2 ^ 2 + 0 - 36 = -8 &
    8 & 3 & 8 \times 2 ^ 2 + 3 - 32 = 3 \\
  \end{tabular}
}

\clearpage

\subsection{Channel Filtering}
\label{mlp:channel_filtering}
{\relsize{-1}
\ALGORITHM{block size, signed residual values, channel's quant step size,\newline FIR filter parameters, IIR filter parameters}{filtered residual values, new FIR state, new IIR state}
\SetKw{AND}{and}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{SHIFT}{shift}
\SetKwData{FIRORDER}{FIR order}
\SetKwData{FIRSHIFT}{FIR shift}
\SetKwData{FIRCOEFF}{FIR coeff}
\SetKwData{FIRSTATE}{FIR state}
\SetKwData{IIRORDER}{IIR order}
\SetKwData{IIRSHIFT}{IIR shift}
\SetKwData{IIRCOEFF}{IIR coeff}
\SetKwData{IIRSTATE}{IIR state}
\SetKwData{RESIDUAL}{residual}
\SetKwData{SUM}{sum}
\SetKwData{SHIFTEDSUM}{shifted sum}
\SetKwData{FILTERED}{filtered}
\SetKwFunction{LEN}{len}
\SetKwFunction{MASK}{mask}
\SetKwData{QUANTSIZE}{quant step size}
\ASSERT $(\text{\FIRORDER}_{s~c} + \text{\IIRORDER}_{s~c}) \leq 8$\;
\uIf{$(\text{\FIRORDER}_{s~c} > 0)$ \AND $(\text{\IIRORDER}_{s~c} > 0)$}{
  \ASSERT $\text{\FIRSHIFT}_{s~c} = \text{\IIRSHIFT}_{s~c}$\;
  $\text{\SHIFT} \leftarrow \text{\FIRSHIFT}_{s~c}$\;
}
\uElseIf{$\text{\FIRORDER} > 0$}{
  $\text{\SHIFT} \leftarrow \text{\FIRSHIFT}_{s~c}$\;
}
\Else{
  $\text{\SHIFT} \leftarrow \text{\IIRSHIFT}_{s~c}$\;
}
\For{$i \leftarrow 0$ \emph{\KwTo}$\text{\BLOCKSIZE}_s$}{
  $\text{\SUM}_i \leftarrow 0$\;
  \For{$j \leftarrow 0$ \emph{\KwTo}$\text{\FIRORDER}_{s~c}$}{
    $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\FIRCOEFF}_{s~c~j} \times \text{\FIRSTATE}_{s~c~(\LEN(\text{\FIRSTATE}) - j - 1)}$\;
  }
  \For{$k \leftarrow 0$ \emph{\KwTo}$\text{\IIRORDER}_{s~c}$}{
    $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\IIRCOEFF}_{s~c~k} \times \text{\IIRSTATE}_{s~c~(\LEN(\text{\IIRSTATE}) - k - 1)}$\;
  }
  \BlankLine
  $\text{\SHIFTEDSUM}_i \leftarrow \lfloor\text{\SUM}_i \div 2 ^ {\SHIFT}\rfloor$\;
  \BlankLine
  $v_i \leftarrow \MASK(\text{\SHIFTEDSUM}_i + \text{\RESIDUAL}_{s~c~i}~,~\text{\QUANTSIZE}_{s~c})$\;
  \BlankLine
  $\text{\FILTERED}_{s~c~i} \leftarrow v_i$\;
  $\text{\FIRSTATE}'_{s~c~\LEN(\text{\FIRSTATE})} \leftarrow v_i$\;
  $\text{\IIRSTATE}'_{s~c~\LEN(\text{\IIRSTATE})} \leftarrow v_i - \text{\SHIFTEDSUM}_i$\;
}
\Return $\left\lbrace\begin{tabular}{l}
$\text{\FILTERED}_{s~c}$ \\
$\text{\FIRSTATE}'_{s~c}$ \\
$\text{\IIRSTATE}'_{s~c}$ \\
\end{tabular}\right.$\;
\EALGORITHM
}
\vskip .25in
\par
\noindent
where \texttt{mask} is defined as:
\begin{equation*}
\texttt{mask}(x~,~q) =\begin{cases}x & \text{ if } q = 0 \\
\lfloor x \div 2 ^ q \rfloor \times 2 ^ q & \text{ if } q > 0
\end{cases}
\end{equation*}
\par
\noindent
Since the maximum FIR order and maximum IIR order are both 8,
one needs to return only the last 8 values of FIR and IIR state.

%%FIXME - add residual filtering example

\clearpage

\subsection{Rematrixing Channels}
\label{mlp:rematrixing}
{\relsize{-1}
\ALGORITHM{block size, filtered residuals, noise shift, noise gen seed, matrix parameters, quant step sizes, bypassed LSBs}{rematrixed channels, updated noise gen seed}
\SetKwData{BLOCKSIZE}{block size}
\SetKwData{NOISE}{noise}
\SetKwData{NOISESHIFT}{noise shift}
\SetKwData{SHIFTED}{shifted}
\SetKwData{NOISEGENSEED}{noise gen seed}
\SetKwData{MATRIXCOUNT}{matrix count}
\SetKwData{SUM}{sum}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{FILTERED}{filtered}
\SetKwData{MATRIXCOEFF}{matrix coefficient}
\SetKwData{REMATRIXED}{rematrixed}
\SetKwData{MATRIXOUTCHANNEL}{matrix out channel}
\SetKwData{QUANTSTEPSIZE}{quant step size}
\SetKwData{BYPASSEDLSB}{bypassed LSB}
\SetKwFunction{MASK}{mask}
\SetKwFunction{CROP}{crop}
\For(\tcc*[f]{generate noise channels}){$i \leftarrow 0$ \emph{\KwTo}$\text{\BLOCKSIZE}_s$}{
  $\text{\SHIFTED}_i \leftarrow \lfloor\text{\NOISEGENSEED}_s \div 2 ^ 7\rfloor \bmod{2 ^ {16}}$\;
  $\text{\NOISE}_{0~i} \leftarrow \CROP(\lfloor\text{\NOISEGENSEED}_s \div 2 ^ {15}\rfloor) \times 2 ^ {\text{\NOISESHIFT}_s}$\;
  $\text{\NOISE}_{1~i} \leftarrow \CROP(\text{\SHIFTED}_i) \times 2 ^ {\text{\NOISESHIFT}_s}$\;
  $\text{\NOISEGENSEED}'_s \leftarrow ((\text{\NOISEGENSEED}_s \times 2 ^ {16}) \bmod{2 ^ {32}}) \xor \text{\SHIFTED}_i \xor (\text{\SHIFTED}_i \times 2 ^ 5)$\;
}
\BlankLine
\For(\tcc*[f]{perform channel rematrixing}){$m \leftarrow 0$ \emph{\KwTo}$\text{\MATRIXCOUNT}_s$}{
  $o \leftarrow \text{\MATRIXOUTCHANNEL}_{s~m}$\;
  \For{$i \leftarrow 0$ \emph{\KwTo}$\text{\BLOCKSIZE}_s$}{
    $\text{\SUM}_i \leftarrow 0$\;
    \For{$c \leftarrow 0$ \emph{\KwTo}$\text{\MAXMATRIXCHANNEL}_s + 1$}{
      $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\FILTERED}_{s~c~i} \times \text{\MATRIXCOEFF}_{s~m~c}$\;
    }
    $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\NOISE}_{0~i} \times \text{\MATRIXCOEFF}_{s~m~(\MAXMATRIXCHANNEL + 1)}$\;
    $\text{\SUM}_i \leftarrow \text{\SUM}_i + \text{\NOISE}_{1~i} \times \text{\MATRIXCOEFF}_{s~m~(\MAXMATRIXCHANNEL + 2)}$\;
    $\text{\FILTERED}_{s~o~i} \leftarrow \MASK(\lfloor\text{\SUM}_i \div 2 ^ {14}\rfloor~,~\text{\QUANTSTEPSIZE}_{s~o}) + \text{\BYPASSEDLSB}_{s~m~i}$\;
  }
}
\Return $\left\lbrace\begin{tabular}{l}
$\text{\FILTERED}_s$ \\
$\text{\NOISEGENSEED}'_s$ \\
\end{tabular}\right.$\;
\EALGORITHM
}
\vskip .25in
\par
\noindent
where \texttt{crop} is defined as:
\begin{align*}
  \texttt{crop}(x) &=
  \begin{cases}
    x \bmod{2 ^ 8} & \text{if } \lfloor (x \bmod{2 ^ 8}) \div 2 ^ 7\rfloor = 0 \\
    (x \bmod{2 ^ 7}) - 2 ^ 7 & \text{if } \lfloor (x \bmod{2 ^ 8}) \div 2 ^ 7\rfloor \neq 0
  \end{cases}
  \intertext{and \texttt{mask} is defined as:}
  \texttt{mask}(x~,~q) &=\begin{cases}x & \text{ if } q = 0 \\
  \lfloor x \div 2 ^ q \rfloor \times 2 ^ q & \text{ if } q > 0
  \end{cases}
\end{align*}

Because each channel may be rematrixed zero or more times,
filtered channels are rematrixed in-place
and the final result is output.

%%FIXME - add rematrixing example

\clearpage

\subsection{Applying Output Shifts}
\label{mlp:output_shifts}
\ALGORITHM{1 or more channels of rematrixed sample data, output shifts}{1 or more channels of shifted sample data}
\SetKwData{MAXMATRIXCHANNEL}{max matrix channel}
\SetKwData{REMATRIXED}{rematrixed}
\SetKwData{OUTPUTSHIFT}{output shift}
\SetKwData{SHIFTED}{shifted}
\For{$c \leftarrow 0$ \emph{\KwTo}$(\text{\MAXMATRIXCHANNEL}_s + 1)$}{
  \eIf{$\text{\OUTPUTSHIFT}_{s~c} > 0$}{
    \For{$i \leftarrow 0$ \emph{\KwTo}$\LEN(\text{\REMATRIXED}_{s~c})$}{
      $\text{\SHIFTED}_{s~c~i} \leftarrow \text{\REMATRIXED}_{s~c~i} \times 2 ^ {\text{\OUTPUTSHIFT}_{s~c}}$\;
    }
  }{
    $\text{\SHIFTED}_{s~c} \leftarrow \text{\REMATRIXED}_{s~c}$\;
  }
}
\Return $\text{\SHIFTED}_{s}$\;
\EALGORITHM

\clearpage

\subsection{Verifying Parity}
\label{mlp:verify_parity}
If \VAR{checkdata present} is indicated in the \VAR{Restart Header},
each substream is followed by a parity and CRC-8 byte.
Calculating the parity value is a simple matter of performing
\xor on all the substream's bytes including the parity byte itself.
If successful, the result should be \texttt{0xA9}.
\par
For example, given the substream bytes:
\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_parity_parse.pdf}
\end{figure}
\begin{align*}
  \text{parity} &= \texttt{0x95} \xor \texttt{0x00} \xor \texttt{0x20} \xor \texttt{0x00} \xor \texttt{0x1C} = \texttt{0xA9}
\end{align*}

\begin{figure}[h]
  \includegraphics{figures/dvda/mlp_frame.pdf}
\end{figure}

\clearpage

\subsection{Verifying CRC-8}
\ALGORITHM{substream bytes, total substream length}{CRC-8 byte to verify}
\SetKwData{SUBSTREAMBYTE}{substream byte}
\SetKwData{SUBSTREAMLEN}{substream length}
\SetKwData{CRC}{CRC}
\SetKwFunction{CRCFUNC}{crc8}
\SetKw{XOR}{xor}
$\text{\CRC}_{(-1)} \leftarrow \texttt{0x3C}$\;
\For{$i \leftarrow 0$ \emph{\KwTo}$(\SUBSTREAMLEN - 3)$}{
  $\text{\CRC}_i \leftarrow \CRCFUNC(\text{\SUBSTREAMBYTE}_i~\XOR~\text{\CRC}_{i - 1})$\;
}
\tcc{CRC-8 calculation skips the parity and CRC-8 bytes}
\Return $\text{\SUBSTREAMBYTE}_{(\SUBSTREAMLEN - 2)}~\XOR~\text{\CRC}_{(\SUBSTREAMLEN - 3)}$\;
\EALGORITHM
\par
\noindent
\texttt{crc8} is taken from the following base-16 table:
\begin{table}[h]
  {\relsize{-1}\ttfamily
    \begin{tabular}{|r||r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|r|}
      \hline
      & ?0 & ?1 & ?2 & ?3 & ?4 & ?5 & ?6 & ?7 & ?8 & ?9 & ?A & ?B & ?C & ?D & ?E & ?F \\
      \hline
      0? & 00 & 63 & C6 & A5 & EF & 8C & 29 & 4A & BD & DE & 7B & 18 & 52 & 31 & 94 & F7 \\
      1? & 19 & 7A & DF & BC & F6 & 95 & 30 & 53 & A4 & C7 & 62 & 01 & 4B & 28 & 8D & EE \\
      2? & 32 & 51 & F4 & 97 & DD & BE & 1B & 78 & 8F & EC & 49 & 2A & 60 & 03 & A6 & C5 \\
      3? & 2B & 48 & ED & 8E & C4 & A7 & 02 & 61 & 96 & F5 & 50 & 33 & 79 & 1A & BF & DC \\
      4? & 64 & 07 & A2 & C1 & 8B & E8 & 4D & 2E & D9 & BA & 1F & 7C & 36 & 55 & F0 & 93 \\
      5? & 7D & 1E & BB & D8 & 92 & F1 & 54 & 37 & C0 & A3 & 06 & 65 & 2F & 4C & E9 & 8A \\
      6? & 56 & 35 & 90 & F3 & B9 & DA & 7F & 1C & EB & 88 & 2D & 4E & 04 & 67 & C2 & A1 \\
      7? & 4F & 2C & 89 & EA & A0 & C3 & 66 & 05 & F2 & 91 & 34 & 57 & 1D & 7E & DB & B8 \\
      8? & C8 & AB & 0E & 6D & 27 & 44 & E1 & 82 & 75 & 16 & B3 & D0 & 9A & F9 & 5C & 3F \\
      9? & D1 & B2 & 17 & 74 & 3E & 5D & F8 & 9B & 6C & 0F & AA & C9 & 83 & E0 & 45 & 26 \\
      A? & FA & 99 & 3C & 5F & 15 & 76 & D3 & B0 & 47 & 24 & 81 & E2 & A8 & CB & 6E & 0D \\
      B? & E3 & 80 & 25 & 46 & 0C & 6F & CA & A9 & 5E & 3D & 98 & FB & B1 & D2 & 77 & 14 \\
      C? & AC & CF & 6A & 09 & 43 & 20 & 85 & E6 & 11 & 72 & D7 & B4 & FE & 9D & 38 & 5B \\
      D? & B5 & D6 & 73 & 10 & 5A & 39 & 9C & FF & 08 & 6B & CE & AD & E7 & 84 & 21 & 42 \\
      E? & 9E & FD & 58 & 3B & 71 & 12 & B7 & D4 & 23 & 40 & E5 & 86 & CC & AF & 0A & 69 \\
      F? & 87 & E4 & 41 & 22 & 68 & 0B & AE & CD & 3A & 59 & FC & 9F & D5 & B6 & 13 & 70 \\
      \hline
    \end{tabular}
  }
\end{table}

Continuing the 6 byte substream example from the previous page,
our CRC-8 calculation is as follows:
\begin{align*}
  \texttt{crc8}(\texttt{0x95} \xor \texttt{0x3C}) = \texttt{crc8}(\texttt{0xA9}) &= \texttt{0x24} \\
  \texttt{crc8}(\texttt{0x00} \xor \texttt{0x24}) = \texttt{crc8}(\texttt{0x24}) &= \texttt{0xDD} \\
  \texttt{crc8}(\texttt{0x20} \xor \texttt{0xDD}) = \texttt{crc8}(\texttt{0xFD}) &= \texttt{0xB6} \\
  \texttt{0x00} \xor \texttt{0xB6} &= \texttt{0xB6}
\end{align*}
which matches the substream's CRC-8 value
and indicates the substream data has been read correctly.
